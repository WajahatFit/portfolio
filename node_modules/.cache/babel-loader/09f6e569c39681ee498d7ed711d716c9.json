{"ast":null,"code":"// code is originally from https://github.com/AnAppAMonth/linewrap\n\n// Presets\nvar presetMap = {\n  'html': {\n    skipScheme: 'html',\n    lineBreakScheme: 'html',\n    whitespace: 'collapse'\n  }\n};\n\n// lineBreak Schemes\nvar brPat = /<\\s*br(?:[\\s/]*|\\s[^>]*)>/gi;\nvar lineBreakSchemeMap = {\n  'unix': [/\\n/g, '\\n'],\n  'dos': [/\\r\\n/g, '\\r\\n'],\n  'mac': [/\\r/g, '\\r'],\n  'html': [brPat, '<br>'],\n  'xhtml': [brPat, '<br/>']\n};\n\n// skip Schemes\nvar skipSchemeMap = {\n  'ansi-color': /\\x1B\\[[^m]*m/g,\n  'html': /<[^>]*>/g,\n  'bbcode': /\\[[^]]*\\]/g\n};\nvar modeMap = {\n  'soft': 1,\n  'hard': 1\n};\nvar wsMap = {\n  'collapse': 1,\n  'default': 1,\n  'line': 1,\n  'all': 1\n};\nvar rlbMap = {\n  'all': 1,\n  'multi': 1,\n  'none': 1\n};\nvar rlbSMPat = /([sm])(\\d+)/;\nvar escapePat = /[-/\\\\^$*+?.()|[\\]{}]/g;\nfunction escapeRegExp(s) {\n  return s.replace(escapePat, '\\\\$&');\n}\nvar linewrap = module.exports = function (start, stop, params) {\n  if (typeof start === 'object') {\n    params = start;\n    start = params.start;\n    stop = params.stop;\n  }\n  if (typeof stop === 'object') {\n    params = stop;\n    start = start || params.start;\n    stop = undefined;\n  }\n  if (!stop) {\n    stop = start;\n    start = 0;\n  }\n  if (!params) {\n    params = {};\n  }\n  // Supported options and default values.\n  var preset,\n    mode = 'soft',\n    whitespace = 'default',\n    tabWidth = 4,\n    skip,\n    skipScheme,\n    lineBreak,\n    lineBreakScheme,\n    respectLineBreaks = 'all',\n    respectNum,\n    preservedLineIndent,\n    wrapLineIndent,\n    wrapLineIndentBase;\n  var skipPat;\n  var lineBreakPat, lineBreakStr;\n  var multiLineBreakPat;\n  var preservedLinePrefix = '';\n  var wrapLineIndentPat,\n    wrapLineInitPrefix = '';\n  var tabRepl;\n  var item, flags;\n  var i;\n\n  // First process presets, because these settings can be overwritten later.\n  preset = params.preset;\n  if (preset) {\n    if (!(preset instanceof Array)) {\n      preset = [preset];\n    }\n    for (i = 0; i < preset.length; i++) {\n      item = presetMap[preset[i]];\n      if (item) {\n        if (item.mode) {\n          mode = item.mode;\n        }\n        if (item.whitespace) {\n          whitespace = item.whitespace;\n        }\n        if (item.tabWidth !== undefined) {\n          tabWidth = item.tabWidth;\n        }\n        if (item.skip) {\n          skip = item.skip;\n        }\n        if (item.skipScheme) {\n          skipScheme = item.skipScheme;\n        }\n        if (item.lineBreak) {\n          lineBreak = item.lineBreak;\n        }\n        if (item.lineBreakScheme) {\n          lineBreakScheme = item.lineBreakScheme;\n        }\n        if (item.respectLineBreaks) {\n          respectLineBreaks = item.respectLineBreaks;\n        }\n        if (item.preservedLineIndent !== undefined) {\n          preservedLineIndent = item.preservedLineIndent;\n        }\n        if (item.wrapLineIndent !== undefined) {\n          wrapLineIndent = item.wrapLineIndent;\n        }\n        if (item.wrapLineIndentBase) {\n          wrapLineIndentBase = item.wrapLineIndentBase;\n        }\n      } else {\n        throw new TypeError('preset must be one of \"' + Object.keys(presetMap).join('\", \"') + '\"');\n      }\n    }\n  }\n  if (params.mode) {\n    if (modeMap[params.mode]) {\n      mode = params.mode;\n    } else {\n      throw new TypeError('mode must be one of \"' + Object.keys(modeMap).join('\", \"') + '\"');\n    }\n  }\n  // Available options: 'collapse', 'default', 'line', and 'all'\n  if (params.whitespace) {\n    if (wsMap[params.whitespace]) {\n      whitespace = params.whitespace;\n    } else {\n      throw new TypeError('whitespace must be one of \"' + Object.keys(wsMap).join('\", \"') + '\"');\n    }\n  }\n  if (params.tabWidth !== undefined) {\n    if (parseInt(params.tabWidth, 10) >= 0) {\n      tabWidth = parseInt(params.tabWidth, 10);\n    } else {\n      throw new TypeError('tabWidth must be a non-negative integer');\n    }\n  }\n  tabRepl = new Array(tabWidth + 1).join(' ');\n\n  // Available options: 'all', 'multi', 'm\\d+', 's\\d+', 'none'\n  if (params.respectLineBreaks) {\n    if (rlbMap[params.respectLineBreaks] || rlbSMPat.test(params.respectLineBreaks)) {\n      respectLineBreaks = params.respectLineBreaks;\n    } else {\n      throw new TypeError('respectLineBreaks must be one of \"' + Object.keys(rlbMap).join('\", \"') + '\", \"m<num>\", \"s<num>\"');\n    }\n  }\n  // After these conversions, now we have 4 options in `respectLineBreaks`:\n  // 'all', 'none', 'm' and 's'.\n  // `respectNum` is applicable iff `respectLineBreaks` is either 'm' or 's'.\n  if (respectLineBreaks === 'multi') {\n    respectLineBreaks = 'm';\n    respectNum = 2;\n  } else if (!rlbMap[respectLineBreaks]) {\n    var match = rlbSMPat.exec(respectLineBreaks);\n    respectLineBreaks = match[1];\n    respectNum = parseInt(match[2], 10);\n  }\n  if (params.preservedLineIndent !== undefined) {\n    if (parseInt(params.preservedLineIndent, 10) >= 0) {\n      preservedLineIndent = parseInt(params.preservedLineIndent, 10);\n    } else {\n      throw new TypeError('preservedLineIndent must be a non-negative integer');\n    }\n  }\n  if (preservedLineIndent > 0) {\n    preservedLinePrefix = new Array(preservedLineIndent + 1).join(' ');\n  }\n  if (params.wrapLineIndent !== undefined) {\n    if (!isNaN(parseInt(params.wrapLineIndent, 10))) {\n      wrapLineIndent = parseInt(params.wrapLineIndent, 10);\n    } else {\n      throw new TypeError('wrapLineIndent must be an integer');\n    }\n  }\n  if (params.wrapLineIndentBase) {\n    wrapLineIndentBase = params.wrapLineIndentBase;\n  }\n  if (wrapLineIndentBase) {\n    if (wrapLineIndent === undefined) {\n      throw new TypeError('wrapLineIndent must be specified when wrapLineIndentBase is specified');\n    }\n    if (wrapLineIndentBase instanceof RegExp) {\n      wrapLineIndentPat = wrapLineIndentBase;\n    } else if (typeof wrapLineIndentBase === 'string') {\n      wrapLineIndentPat = new RegExp(escapeRegExp(wrapLineIndentBase));\n    } else {\n      throw new TypeError('wrapLineIndentBase must be either a RegExp object or a string');\n    }\n  } else if (wrapLineIndent > 0) {\n    wrapLineInitPrefix = new Array(wrapLineIndent + 1).join(' ');\n  } else if (wrapLineIndent < 0) {\n    throw new TypeError('wrapLineIndent must be non-negative when a base is not specified');\n  }\n\n  // NOTE: For the two RegExps `skipPat` and `lineBreakPat` that can be specified\n  //       by the user:\n  //       1. We require them to be \"global\", so we have to convert them to global\n  //          if the user specifies a non-global regex.\n  //       2. We cannot call `split()` on them, because they may or may not contain\n  //          capturing parentheses which affect the output of `split()`.\n\n  // Precedence: Regex = Str > Scheme\n  if (params.skipScheme) {\n    if (skipSchemeMap[params.skipScheme]) {\n      skipScheme = params.skipScheme;\n    } else {\n      throw new TypeError('skipScheme must be one of \"' + Object.keys(skipSchemeMap).join('\", \"') + '\"');\n    }\n  }\n  if (params.skip) {\n    skip = params.skip;\n  }\n  if (skip) {\n    if (skip instanceof RegExp) {\n      skipPat = skip;\n      if (!skipPat.global) {\n        flags = 'g';\n        if (skipPat.ignoreCase) {\n          flags += 'i';\n        }\n        if (skipPat.multiline) {\n          flags += 'm';\n        }\n        skipPat = new RegExp(skipPat.source, flags);\n      }\n    } else if (typeof skip === 'string') {\n      skipPat = new RegExp(escapeRegExp(skip), 'g');\n    } else {\n      throw new TypeError('skip must be either a RegExp object or a string');\n    }\n  }\n  if (!skipPat && skipScheme) {\n    skipPat = skipSchemeMap[skipScheme];\n  }\n\n  // Precedence:\n  // - for lineBreakPat: Regex > Scheme > Str\n  // - for lineBreakStr: Str > Scheme > Regex\n  if (params.lineBreakScheme) {\n    if (lineBreakSchemeMap[params.lineBreakScheme]) {\n      lineBreakScheme = params.lineBreakScheme;\n    } else {\n      throw new TypeError('lineBreakScheme must be one of \"' + Object.keys(lineBreakSchemeMap).join('\", \"') + '\"');\n    }\n  }\n  if (params.lineBreak) {\n    lineBreak = params.lineBreak;\n  }\n  if (lineBreakScheme) {\n    // Supported schemes: 'unix', 'dos', 'mac', 'html', 'xhtml'\n    item = lineBreakSchemeMap[lineBreakScheme];\n    if (item) {\n      lineBreakPat = item[0];\n      lineBreakStr = item[1];\n    }\n  }\n  if (lineBreak) {\n    if (lineBreak instanceof Array) {\n      if (lineBreak.length === 1) {\n        lineBreak = lineBreak[0];\n      } else if (lineBreak.length >= 2) {\n        if (lineBreak[0] instanceof RegExp) {\n          lineBreakPat = lineBreak[0];\n          if (typeof lineBreak[1] === 'string') {\n            lineBreakStr = lineBreak[1];\n          }\n        } else if (lineBreak[1] instanceof RegExp) {\n          lineBreakPat = lineBreak[1];\n          if (typeof lineBreak[0] === 'string') {\n            lineBreakStr = lineBreak[0];\n          }\n        } else if (typeof lineBreak[0] === 'string' && typeof lineBreak[1] === 'string') {\n          lineBreakPat = new RegExp(escapeRegExp(lineBreak[0]), 'g');\n          lineBreakStr = lineBreak[1];\n        } else {\n          lineBreak = lineBreak[0];\n        }\n      }\n    }\n    if (typeof lineBreak === 'string') {\n      lineBreakStr = lineBreak;\n      if (!lineBreakPat) {\n        lineBreakPat = new RegExp(escapeRegExp(lineBreak), 'g');\n      }\n    } else if (lineBreak instanceof RegExp) {\n      lineBreakPat = lineBreak;\n    } else if (!(lineBreak instanceof Array)) {\n      throw new TypeError('lineBreak must be a RegExp object, a string, or an array consisted of a RegExp object and a string');\n    }\n  }\n  // Only assign defaults when `lineBreakPat` is not assigned.\n  // So if `params.lineBreak` is a RegExp, we don't have a value in `lineBreakStr`\n  // yet. We will try to get the value from the input string, and if failed, we\n  // will throw an exception.\n  if (!lineBreakPat) {\n    lineBreakPat = /\\n/g;\n    lineBreakStr = '\\n';\n  }\n\n  // Create `multiLineBreakPat` based on `lineBreakPat`, that matches strings\n  // consisted of one or more line breaks and zero or more whitespaces.\n  // Also convert `lineBreakPat` to global if not already so.\n  flags = 'g';\n  if (lineBreakPat.ignoreCase) {\n    flags += 'i';\n  }\n  if (lineBreakPat.multiline) {\n    flags += 'm';\n  }\n  multiLineBreakPat = new RegExp('\\\\s*(?:' + lineBreakPat.source + ')(?:' + lineBreakPat.source + '|\\\\s)*', flags);\n  if (!lineBreakPat.global) {\n    lineBreakPat = new RegExp(lineBreakPat.source, flags);\n  }\n\n  // Initialize other useful variables.\n  var re = mode === 'hard' ? /\\b/ : /(\\S+\\s+)/;\n  var prefix = new Array(start + 1).join(' ');\n  var wsStrip = whitespace === 'default' || whitespace === 'collapse',\n    wsCollapse = whitespace === 'collapse',\n    wsLine = whitespace === 'line',\n    wsAll = whitespace === 'all';\n  var tabPat = /\\t/g,\n    collapsePat = /  +/g,\n    pPat = /^\\s+/,\n    tPat = /\\s+$/,\n    nonWsPat = /\\S/,\n    wsPat = /\\s/;\n  var wrapLen = stop - start;\n  return function (text) {\n    text = text.toString().replace(tabPat, tabRepl);\n    var match;\n    if (!lineBreakStr) {\n      // Try to get lineBreakStr from `text`\n      lineBreakPat.lastIndex = 0;\n      match = lineBreakPat.exec(text);\n      if (match) {\n        lineBreakStr = match[0];\n      } else {\n        throw new TypeError('Line break string for the output not specified');\n      }\n    }\n\n    // text -> blocks; each bloc -> segments; each segment -> chunks\n    var blocks,\n      base = 0;\n    var mo, arr, b, res;\n    // Split `text` by line breaks.\n    blocks = [];\n    multiLineBreakPat.lastIndex = 0;\n    match = multiLineBreakPat.exec(text);\n    while (match) {\n      blocks.push(text.substring(base, match.index));\n      if (respectLineBreaks !== 'none') {\n        arr = [];\n        b = 0;\n        lineBreakPat.lastIndex = 0;\n        mo = lineBreakPat.exec(match[0]);\n        while (mo) {\n          arr.push(match[0].substring(b, mo.index));\n          b = mo.index + mo[0].length;\n          mo = lineBreakPat.exec(match[0]);\n        }\n        arr.push(match[0].substring(b));\n        blocks.push({\n          type: 'break',\n          breaks: arr\n        });\n      } else {\n        // Strip line breaks and insert spaces when necessary.\n        if (wsCollapse) {\n          res = ' ';\n        } else {\n          res = match[0].replace(lineBreakPat, '');\n        }\n        blocks.push({\n          type: 'break',\n          remaining: res\n        });\n      }\n      base = match.index + match[0].length;\n      match = multiLineBreakPat.exec(text);\n    }\n    blocks.push(text.substring(base));\n    var i, j, k;\n    var segments;\n    if (skipPat) {\n      segments = [];\n      for (i = 0; i < blocks.length; i++) {\n        var bloc = blocks[i];\n        if (typeof bloc !== 'string') {\n          // This is an object.\n          segments.push(bloc);\n        } else {\n          base = 0;\n          skipPat.lastIndex = 0;\n          match = skipPat.exec(bloc);\n          while (match) {\n            segments.push(bloc.substring(base, match.index));\n            segments.push({\n              type: 'skip',\n              value: match[0]\n            });\n            base = match.index + match[0].length;\n            match = skipPat.exec(bloc);\n          }\n          segments.push(bloc.substring(base));\n        }\n      }\n    } else {\n      segments = blocks;\n    }\n    var chunks = [];\n    for (i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n      if (typeof segment !== 'string') {\n        // This is an object.\n        chunks.push(segment);\n      } else {\n        if (wsCollapse) {\n          segment = segment.replace(collapsePat, ' ');\n        }\n        var parts = segment.split(re),\n          acc = [];\n        for (j = 0; j < parts.length; j++) {\n          var x = parts[j];\n          if (mode === 'hard') {\n            for (k = 0; k < x.length; k += wrapLen) {\n              acc.push(x.slice(k, k + wrapLen));\n            }\n          } else {\n            acc.push(x);\n          }\n        }\n        chunks = chunks.concat(acc);\n      }\n    }\n    var curLine = 0,\n      curLineLength = start + preservedLinePrefix.length,\n      lines = [prefix + preservedLinePrefix],\n      // Holds the \"real length\" (excluding trailing whitespaces) of the\n      // current line if it exceeds `stop`, otherwise 0.\n      // ONLY USED when `wsAll` is true, in `finishOffCurLine()`.\n      bulge = 0,\n      // `cleanLine` is true iff we are at the beginning of an output line. By\n      // \"beginning\" we mean it doesn't contain any non-whitespace char yet.\n      // But its `curLineLength` can be greater than `start`, or even possibly\n      // be greater than `stop`, if `wsStrip` is false.\n      //\n      // Note that a \"clean\" line can still contain skip strings, in addition\n      // to whitespaces.\n      //\n      // This variable is used to allow us strip preceding whitespaces when\n      // `wsStrip` is true, or `wsLine` is true and `preservedLine` is false.\n      cleanLine = true,\n      // `preservedLine` is true iff we are in a preserved input line.\n      //\n      // It's used when `wsLine` is true to (combined with `cleanLine`) decide\n      // whether a whitespace is at the beginning of a preserved input line and\n      // should not be stripped.\n      preservedLine = true,\n      // The current indent prefix for wrapped lines.\n      wrapLinePrefix = wrapLineInitPrefix,\n      remnant;\n\n    // Always returns '' if `beforeHardBreak` is true.\n    //\n    // Assumption: Each call of this function is always followed by a `lines.push()` call.\n    //\n    // This function can change the status of `cleanLine`, but we don't modify the value of\n    // `cleanLine` in this function. It's fine because `cleanLine` will be set to the correct\n    // value after the `lines.push()` call following this function call. We also don't update\n    // `curLineLength` when pushing a new line and it's safe for the same reason.\n    function finishOffCurLine(beforeHardBreak) {\n      var str = lines[curLine],\n        idx,\n        ln,\n        rBase;\n      if (!wsAll) {\n        // Strip all trailing whitespaces past `start`.\n        idx = str.length - 1;\n        while (idx >= start && str[idx] === ' ') {\n          idx--;\n        }\n        while (idx >= start && wsPat.test(str[idx])) {\n          idx--;\n        }\n        idx++;\n        if (idx !== str.length) {\n          lines[curLine] = str.substring(0, idx);\n        }\n        if (preservedLine && cleanLine && wsLine && curLineLength > stop) {\n          // Add the remnants to the next line, just like when `wsAll` is true.\n          rBase = str.length - (curLineLength - stop);\n          if (rBase < idx) {\n            // We didn't reach `stop` when stripping due to a bulge.\n            rBase = idx;\n          }\n        }\n      } else {\n        // Strip trailing whitespaces exceeding stop.\n        if (curLineLength > stop) {\n          bulge = bulge || stop;\n          rBase = str.length - (curLineLength - bulge);\n          lines[curLine] = str.substring(0, rBase);\n        }\n        bulge = 0;\n      }\n\n      // Bug: the current implementation of `wrapLineIndent` is buggy: we are not\n      // taking the extra space occupied by the additional indentation into account\n      // when wrapping the line. For example, in \"hard\" mode, we should hard-wrap\n      // long words at `wrapLen - wrapLinePrefix.length` instead of `wrapLen`\n      // and remnants should also be wrapped at `wrapLen - wrapLinePrefix.length`.\n      if (preservedLine) {\n        // This is a preserved line, and the next output line isn't a\n        // preserved line.\n        preservedLine = false;\n        if (wrapLineIndentPat) {\n          idx = lines[curLine].substring(start).search(wrapLineIndentPat);\n          if (idx >= 0 && idx + wrapLineIndent > 0) {\n            wrapLinePrefix = new Array(idx + wrapLineIndent + 1).join(' ');\n          } else {\n            wrapLinePrefix = '';\n          }\n        }\n      }\n\n      // Some remnants are left to the next line.\n      if (rBase) {\n        while (rBase + wrapLen < str.length) {\n          if (wsAll) {\n            ln = str.substring(rBase, rBase + wrapLen);\n            lines.push(prefix + wrapLinePrefix + ln);\n          } else {\n            lines.push(prefix + wrapLinePrefix);\n          }\n          rBase += wrapLen;\n          curLine++;\n        }\n        if (beforeHardBreak) {\n          if (wsAll) {\n            ln = str.substring(rBase);\n            lines.push(prefix + wrapLinePrefix + ln);\n          } else {\n            lines.push(prefix + wrapLinePrefix);\n          }\n          curLine++;\n        } else {\n          ln = str.substring(rBase);\n          return wrapLinePrefix + ln;\n        }\n      }\n      return '';\n    }\n    for (i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n      if (chunk === '') {\n        continue;\n      }\n      if (typeof chunk !== 'string') {\n        if (chunk.type === 'break') {\n          // This is one or more line breaks.\n          // Each entry in `breaks` is just zero or more whitespaces.\n          if (respectLineBreaks !== 'none') {\n            // Note that if `whitespace` is \"collapse\", we still need\n            // to collapse whitespaces in entries of `breaks`.\n            var breaks = chunk.breaks;\n            var num = breaks.length - 1;\n            if (respectLineBreaks === 's') {\n              // This is the most complex scenario. We have to check\n              // the line breaks one by one.\n              for (j = 0; j < num; j++) {\n                if (breaks[j + 1].length < respectNum) {\n                  // This line break should be stripped.\n                  if (wsCollapse) {\n                    breaks[j + 1] = ' ';\n                  } else {\n                    breaks[j + 1] = breaks[j] + breaks[j + 1];\n                  }\n                } else {\n                  // This line break should be preserved.\n                  // First finish off the current line.\n                  if (wsAll) {\n                    lines[curLine] += breaks[j];\n                    curLineLength += breaks[j].length;\n                  }\n                  finishOffCurLine(true);\n                  lines.push(prefix + preservedLinePrefix);\n                  curLine++;\n                  curLineLength = start + preservedLinePrefix.length;\n                  preservedLine = cleanLine = true;\n                }\n              }\n              // We are adding to either the existing line (if no line break\n              // is qualified for preservance) or a \"new\" line.\n              if (!cleanLine || wsAll || wsLine && preservedLine) {\n                if (wsCollapse || !cleanLine && breaks[num] === '') {\n                  breaks[num] = ' ';\n                }\n                lines[curLine] += breaks[num];\n                curLineLength += breaks[num].length;\n              }\n            } else if (respectLineBreaks === 'm' && num < respectNum) {\n              // These line breaks should be stripped.\n              if (!cleanLine || wsAll || wsLine && preservedLine) {\n                if (wsCollapse) {\n                  chunk = ' ';\n                } else {\n                  chunk = breaks.join('');\n                  if (!cleanLine && chunk === '') {\n                    chunk = ' ';\n                  }\n                }\n                lines[curLine] += chunk;\n                curLineLength += chunk.length;\n              }\n            } else {\n              // 'all' || ('m' && num >= respectNum)\n              // These line breaks should be preserved.\n              if (wsStrip) {\n                // Finish off the current line.\n                finishOffCurLine(true);\n                for (j = 0; j < num; j++) {\n                  lines.push(prefix + preservedLinePrefix);\n                  curLine++;\n                }\n                curLineLength = start + preservedLinePrefix.length;\n                preservedLine = cleanLine = true;\n              } else {\n                if (wsAll || preservedLine && cleanLine) {\n                  lines[curLine] += breaks[0];\n                  curLineLength += breaks[0].length;\n                }\n                for (j = 0; j < num; j++) {\n                  // Finish off the current line.\n                  finishOffCurLine(true);\n                  lines.push(prefix + preservedLinePrefix + breaks[j + 1]);\n                  curLine++;\n                  curLineLength = start + preservedLinePrefix.length + breaks[j + 1].length;\n                  preservedLine = cleanLine = true;\n                }\n              }\n            }\n          } else {\n            // These line breaks should be stripped.\n            if (!cleanLine || wsAll || wsLine && preservedLine) {\n              chunk = chunk.remaining;\n\n              // Bug: If `wsAll` is true, `cleanLine` is false, and `chunk`\n              // is '', we insert a space to replace the line break. This\n              // space will be preserved even if we are at the end of an\n              // output line, which is wrong behavior. However, I'm not\n              // sure it's worth it to fix this edge case.\n              if (wsCollapse || !cleanLine && chunk === '') {\n                chunk = ' ';\n              }\n              lines[curLine] += chunk;\n              curLineLength += chunk.length;\n            }\n          }\n        } else if (chunk.type === 'skip') {\n          // This is a skip string.\n          // Assumption: skip strings don't end with whitespaces.\n          if (curLineLength > stop) {\n            remnant = finishOffCurLine(false);\n            lines.push(prefix + wrapLinePrefix);\n            curLine++;\n            curLineLength = start + wrapLinePrefix.length;\n            if (remnant) {\n              lines[curLine] += remnant;\n              curLineLength += remnant.length;\n            }\n            cleanLine = true;\n          }\n          lines[curLine] += chunk.value;\n        }\n        continue;\n      }\n      var chunk2;\n      while (1) {\n        chunk2 = undefined;\n        if (curLineLength + chunk.length > stop && curLineLength + (chunk2 = chunk.replace(tPat, '')).length > stop && chunk2 !== '' && curLineLength > start) {\n          // This line is full, add `chunk` to the next line\n          remnant = finishOffCurLine(false);\n          lines.push(prefix + wrapLinePrefix);\n          curLine++;\n          curLineLength = start + wrapLinePrefix.length;\n          if (remnant) {\n            lines[curLine] += remnant;\n            curLineLength += remnant.length;\n            cleanLine = true;\n            continue;\n          }\n          if (wsStrip || wsLine && !(preservedLine && cleanLine)) {\n            chunk = chunk.replace(pPat, '');\n          }\n          cleanLine = false;\n        } else {\n          // Add `chunk` to this line\n          if (cleanLine) {\n            if (wsStrip || wsLine && !(preservedLine && cleanLine)) {\n              chunk = chunk.replace(pPat, '');\n              if (chunk !== '') {\n                cleanLine = false;\n              }\n            } else {\n              if (nonWsPat.test(chunk)) {\n                cleanLine = false;\n              }\n            }\n          }\n        }\n        break;\n      }\n      if (wsAll && chunk2 && curLineLength + chunk2.length > stop) {\n        bulge = curLineLength + chunk2.length;\n      }\n      lines[curLine] += chunk;\n      curLineLength += chunk.length;\n    }\n    // Finally, finish off the last line.\n    finishOffCurLine(true);\n    return lines.join(lineBreakStr);\n  };\n};\nlinewrap.soft = linewrap;\nlinewrap.hard = function /*start, stop, params*/\n() {\n  var args = [].slice.call(arguments);\n  var last = args.length - 1;\n  if (typeof args[last] === 'object') {\n    args[last].mode = 'hard';\n  } else {\n    args.push({\n      mode: 'hard'\n    });\n  }\n  return linewrap.apply(null, args);\n};\nlinewrap.wrap = function (text /*, start, stop, params*/) {\n  var args = [].slice.call(arguments);\n  args.shift();\n  return linewrap.apply(null, args)(text);\n};","map":{"version":3,"names":["presetMap","skipScheme","lineBreakScheme","whitespace","brPat","lineBreakSchemeMap","skipSchemeMap","modeMap","wsMap","rlbMap","rlbSMPat","escapePat","escapeRegExp","s","replace","linewrap","module","exports","start","stop","params","undefined","preset","mode","tabWidth","skip","lineBreak","respectLineBreaks","respectNum","preservedLineIndent","wrapLineIndent","wrapLineIndentBase","skipPat","lineBreakPat","lineBreakStr","multiLineBreakPat","preservedLinePrefix","wrapLineIndentPat","wrapLineInitPrefix","tabRepl","item","flags","i","Array","length","TypeError","Object","keys","join","parseInt","test","match","exec","isNaN","RegExp","global","ignoreCase","multiline","source","re","prefix","wsStrip","wsCollapse","wsLine","wsAll","tabPat","collapsePat","pPat","tPat","nonWsPat","wsPat","wrapLen","text","toString","lastIndex","blocks","base","mo","arr","b","res","push","substring","index","type","breaks","remaining","j","k","segments","bloc","value","chunks","segment","parts","split","acc","x","slice","concat","curLine","curLineLength","lines","bulge","cleanLine","preservedLine","wrapLinePrefix","remnant","finishOffCurLine","beforeHardBreak","str","idx","ln","rBase","search","chunk","num","chunk2","soft","hard","args","call","arguments","last","apply","wrap","shift"],"sources":["/Users/wajahatfit/Documents/labs/portfolio/portfolio/node_modules/@oclif/linewrap/linewrap.js"],"sourcesContent":["// code is originally from https://github.com/AnAppAMonth/linewrap\n\n// Presets\nvar presetMap = {\n  'html': {\n    skipScheme: 'html',\n    lineBreakScheme: 'html',\n    whitespace: 'collapse'\n  }\n}\n\n// lineBreak Schemes\nvar brPat = /<\\s*br(?:[\\s/]*|\\s[^>]*)>/gi\nvar lineBreakSchemeMap = {\n  'unix': [/\\n/g, '\\n'],\n  'dos': [/\\r\\n/g, '\\r\\n'],\n  'mac': [/\\r/g, '\\r'],\n  'html': [brPat, '<br>'],\n  'xhtml': [brPat, '<br/>']\n}\n\n// skip Schemes\nvar skipSchemeMap = {\n  'ansi-color': /\\x1B\\[[^m]*m/g,\n  'html': /<[^>]*>/g,\n  'bbcode': /\\[[^]]*\\]/g\n}\n\nvar modeMap = {\n  'soft': 1,\n  'hard': 1\n}\n\nvar wsMap = {\n  'collapse': 1,\n  'default': 1,\n  'line': 1,\n  'all': 1\n}\n\nvar rlbMap = {\n  'all': 1,\n  'multi': 1,\n  'none': 1\n}\nvar rlbSMPat = /([sm])(\\d+)/\n\nvar escapePat = /[-/\\\\^$*+?.()|[\\]{}]/g\nfunction escapeRegExp (s) {\n  return s.replace(escapePat, '\\\\$&')\n}\n\nvar linewrap = module.exports = function (start, stop, params) {\n  if (typeof start === 'object') {\n    params = start\n    start = params.start\n    stop = params.stop\n  }\n\n  if (typeof stop === 'object') {\n    params = stop\n    start = start || params.start\n    stop = undefined\n  }\n\n  if (!stop) {\n    stop = start\n    start = 0\n  }\n\n  if (!params) { params = {}; }\n  // Supported options and default values.\n  var preset,\n    mode = 'soft',\n    whitespace = 'default',\n    tabWidth = 4,\n    skip, skipScheme, lineBreak, lineBreakScheme,\n    respectLineBreaks = 'all',\n    respectNum,\n    preservedLineIndent,\n    wrapLineIndent, wrapLineIndentBase\n\n  var skipPat\n  var lineBreakPat, lineBreakStr\n  var multiLineBreakPat\n  var preservedLinePrefix = ''\n  var wrapLineIndentPat, wrapLineInitPrefix = ''\n  var tabRepl\n  var item, flags\n  var i\n\n  // First process presets, because these settings can be overwritten later.\n  preset = params.preset\n  if (preset) {\n    if (!(preset instanceof Array)) {\n      preset = [preset]\n    }\n    for (i = 0; i < preset.length; i++) {\n      item = presetMap[preset[i]]\n      if (item) {\n        if (item.mode) {\n          mode = item.mode\n        }\n        if (item.whitespace) {\n          whitespace = item.whitespace\n        }\n        if (item.tabWidth !== undefined) {\n          tabWidth = item.tabWidth\n        }\n        if (item.skip) {\n          skip = item.skip\n        }\n        if (item.skipScheme) {\n          skipScheme = item.skipScheme\n        }\n        if (item.lineBreak) {\n          lineBreak = item.lineBreak\n        }\n        if (item.lineBreakScheme) {\n          lineBreakScheme = item.lineBreakScheme\n        }\n        if (item.respectLineBreaks) {\n          respectLineBreaks = item.respectLineBreaks\n        }\n        if (item.preservedLineIndent !== undefined) {\n          preservedLineIndent = item.preservedLineIndent\n        }\n        if (item.wrapLineIndent !== undefined) {\n          wrapLineIndent = item.wrapLineIndent\n        }\n        if (item.wrapLineIndentBase) {\n          wrapLineIndentBase = item.wrapLineIndentBase\n        }\n      } else {\n        throw new TypeError('preset must be one of \"' + Object.keys(presetMap).join('\", \"') + '\"')\n      }\n    }\n  }\n\n  if (params.mode) {\n    if (modeMap[params.mode]) {\n      mode = params.mode\n    } else {\n      throw new TypeError('mode must be one of \"' + Object.keys(modeMap).join('\", \"') + '\"')\n    }\n  }\n  // Available options: 'collapse', 'default', 'line', and 'all'\n  if (params.whitespace) {\n    if (wsMap[params.whitespace]) {\n      whitespace = params.whitespace\n    } else {\n      throw new TypeError('whitespace must be one of \"' + Object.keys(wsMap).join('\", \"') + '\"')\n    }\n  }\n\n  if (params.tabWidth !== undefined) {\n    if (parseInt(params.tabWidth, 10) >= 0) {\n      tabWidth = parseInt(params.tabWidth, 10)\n    } else {\n      throw new TypeError('tabWidth must be a non-negative integer')\n    }\n  }\n  tabRepl = new Array(tabWidth + 1).join(' ')\n\n  // Available options: 'all', 'multi', 'm\\d+', 's\\d+', 'none'\n  if (params.respectLineBreaks) {\n    if (rlbMap[params.respectLineBreaks] || rlbSMPat.test(params.respectLineBreaks)) {\n      respectLineBreaks = params.respectLineBreaks\n    } else {\n      throw new TypeError('respectLineBreaks must be one of \"' + Object.keys(rlbMap).join('\", \"') +\n        '\", \"m<num>\", \"s<num>\"')\n    }\n  }\n  // After these conversions, now we have 4 options in `respectLineBreaks`:\n  // 'all', 'none', 'm' and 's'.\n  // `respectNum` is applicable iff `respectLineBreaks` is either 'm' or 's'.\n  if (respectLineBreaks === 'multi') {\n    respectLineBreaks = 'm'\n    respectNum = 2\n  } else if (!rlbMap[respectLineBreaks]) {\n    var match = rlbSMPat.exec(respectLineBreaks)\n    respectLineBreaks = match[1]\n    respectNum = parseInt(match[2], 10)\n  }\n\n  if (params.preservedLineIndent !== undefined) {\n    if (parseInt(params.preservedLineIndent, 10) >= 0) {\n      preservedLineIndent = parseInt(params.preservedLineIndent, 10)\n    } else {\n      throw new TypeError('preservedLineIndent must be a non-negative integer')\n    }\n  }\n\n  if (preservedLineIndent > 0) {\n    preservedLinePrefix = new Array(preservedLineIndent + 1).join(' ')\n  }\n\n  if (params.wrapLineIndent !== undefined) {\n    if (!isNaN(parseInt(params.wrapLineIndent, 10))) {\n      wrapLineIndent = parseInt(params.wrapLineIndent, 10)\n    } else {\n      throw new TypeError('wrapLineIndent must be an integer')\n    }\n  }\n  if (params.wrapLineIndentBase) {\n    wrapLineIndentBase = params.wrapLineIndentBase\n  }\n\n  if (wrapLineIndentBase) {\n    if (wrapLineIndent === undefined) {\n      throw new TypeError('wrapLineIndent must be specified when wrapLineIndentBase is specified')\n    }\n    if (wrapLineIndentBase instanceof RegExp) {\n      wrapLineIndentPat = wrapLineIndentBase\n    } else if (typeof wrapLineIndentBase === 'string') {\n      wrapLineIndentPat = new RegExp(escapeRegExp(wrapLineIndentBase))\n    } else {\n      throw new TypeError('wrapLineIndentBase must be either a RegExp object or a string')\n    }\n  } else if (wrapLineIndent > 0) {\n    wrapLineInitPrefix = new Array(wrapLineIndent + 1).join(' ')\n  } else if (wrapLineIndent < 0) {\n    throw new TypeError('wrapLineIndent must be non-negative when a base is not specified')\n  }\n\n  // NOTE: For the two RegExps `skipPat` and `lineBreakPat` that can be specified\n  //       by the user:\n  //       1. We require them to be \"global\", so we have to convert them to global\n  //          if the user specifies a non-global regex.\n  //       2. We cannot call `split()` on them, because they may or may not contain\n  //          capturing parentheses which affect the output of `split()`.\n\n  // Precedence: Regex = Str > Scheme\n  if (params.skipScheme) {\n    if (skipSchemeMap[params.skipScheme]) {\n      skipScheme = params.skipScheme\n    } else {\n      throw new TypeError('skipScheme must be one of \"' + Object.keys(skipSchemeMap).join('\", \"') + '\"')\n    }\n  }\n  if (params.skip) {\n    skip = params.skip\n  }\n\n  if (skip) {\n    if (skip instanceof RegExp) {\n      skipPat = skip\n      if (!skipPat.global) {\n        flags = 'g'\n        if (skipPat.ignoreCase) { flags += 'i'; }\n        if (skipPat.multiline) { flags += 'm'; }\n        skipPat = new RegExp(skipPat.source, flags)\n      }\n    } else if (typeof skip === 'string') {\n      skipPat = new RegExp(escapeRegExp(skip), 'g')\n    } else {\n      throw new TypeError('skip must be either a RegExp object or a string')\n    }\n  }\n  if (!skipPat && skipScheme) {\n    skipPat = skipSchemeMap[skipScheme]\n  }\n\n  // Precedence:\n  // - for lineBreakPat: Regex > Scheme > Str\n  // - for lineBreakStr: Str > Scheme > Regex\n  if (params.lineBreakScheme) {\n    if (lineBreakSchemeMap[params.lineBreakScheme]) {\n      lineBreakScheme = params.lineBreakScheme\n    } else {\n      throw new TypeError('lineBreakScheme must be one of \"' + Object.keys(lineBreakSchemeMap).join('\", \"') + '\"')\n    }\n  }\n  if (params.lineBreak) {\n    lineBreak = params.lineBreak\n  }\n\n  if (lineBreakScheme) {\n    // Supported schemes: 'unix', 'dos', 'mac', 'html', 'xhtml'\n    item = lineBreakSchemeMap[lineBreakScheme]\n    if (item) {\n      lineBreakPat = item[0]\n      lineBreakStr = item[1]\n    }\n  }\n  if (lineBreak) {\n    if (lineBreak instanceof Array) {\n      if (lineBreak.length === 1) {\n        lineBreak = lineBreak[0]\n      } else if (lineBreak.length >= 2) {\n        if (lineBreak[0] instanceof RegExp) {\n          lineBreakPat = lineBreak[0]\n          if (typeof lineBreak[1] === 'string') {\n            lineBreakStr = lineBreak[1]\n          }\n        } else if (lineBreak[1] instanceof RegExp) {\n          lineBreakPat = lineBreak[1]\n          if (typeof lineBreak[0] === 'string') {\n            lineBreakStr = lineBreak[0]\n          }\n        } else if (typeof lineBreak[0] === 'string' && typeof lineBreak[1] === 'string') {\n          lineBreakPat = new RegExp(escapeRegExp(lineBreak[0]), 'g')\n          lineBreakStr = lineBreak[1]\n        } else {\n          lineBreak = lineBreak[0]\n        }\n      }\n    }\n    if (typeof lineBreak === 'string') {\n      lineBreakStr = lineBreak\n      if (!lineBreakPat) {\n        lineBreakPat = new RegExp(escapeRegExp(lineBreak), 'g')\n      }\n    } else if (lineBreak instanceof RegExp) {\n      lineBreakPat = lineBreak\n    } else if (!(lineBreak instanceof Array)) {\n      throw new TypeError('lineBreak must be a RegExp object, a string, or an array consisted of a RegExp object and a string')\n    }\n  }\n  // Only assign defaults when `lineBreakPat` is not assigned.\n  // So if `params.lineBreak` is a RegExp, we don't have a value in `lineBreakStr`\n  // yet. We will try to get the value from the input string, and if failed, we\n  // will throw an exception.\n  if (!lineBreakPat) {\n    lineBreakPat = /\\n/g\n    lineBreakStr = '\\n'\n  }\n\n  // Create `multiLineBreakPat` based on `lineBreakPat`, that matches strings\n  // consisted of one or more line breaks and zero or more whitespaces.\n  // Also convert `lineBreakPat` to global if not already so.\n  flags = 'g'\n  if (lineBreakPat.ignoreCase) { flags += 'i'; }\n  if (lineBreakPat.multiline) { flags += 'm'; }\n  multiLineBreakPat = new RegExp('\\\\s*(?:' + lineBreakPat.source + ')(?:' +\n    lineBreakPat.source + '|\\\\s)*', flags)\n  if (!lineBreakPat.global) {\n    lineBreakPat = new RegExp(lineBreakPat.source, flags)\n  }\n\n  // Initialize other useful variables.\n  var re = mode === 'hard' ? /\\b/ : /(\\S+\\s+)/\n  var prefix = new Array(start + 1).join(' ')\n  var wsStrip = (whitespace === 'default' || whitespace === 'collapse'),\n    wsCollapse = (whitespace === 'collapse'),\n    wsLine = (whitespace === 'line'),\n    wsAll = (whitespace === 'all')\n  var tabPat = /\\t/g,\n    collapsePat = /  +/g,\n    pPat = /^\\s+/,\n    tPat = /\\s+$/,\n    nonWsPat = /\\S/,\n    wsPat = /\\s/\n  var wrapLen = stop - start\n\n  return function (text) {\n    text = text.toString().replace(tabPat, tabRepl)\n\n    var match\n    if (!lineBreakStr) {\n      // Try to get lineBreakStr from `text`\n      lineBreakPat.lastIndex = 0\n      match = lineBreakPat.exec(text)\n      if (match) {\n        lineBreakStr = match[0]\n      } else {\n        throw new TypeError('Line break string for the output not specified')\n      }\n    }\n\n    // text -> blocks; each bloc -> segments; each segment -> chunks\n    var blocks, base = 0\n    var mo, arr, b, res\n    // Split `text` by line breaks.\n    blocks = []\n    multiLineBreakPat.lastIndex = 0\n    match = multiLineBreakPat.exec(text)\n    while(match) {\n      blocks.push(text.substring(base, match.index))\n\n      if (respectLineBreaks !== 'none') {\n        arr = []\n        b = 0\n        lineBreakPat.lastIndex = 0\n        mo = lineBreakPat.exec(match[0])\n        while(mo) {\n          arr.push(match[0].substring(b, mo.index))\n          b = mo.index + mo[0].length\n          mo = lineBreakPat.exec(match[0])\n        }\n        arr.push(match[0].substring(b))\n        blocks.push({type: 'break', breaks: arr})\n      } else {\n        // Strip line breaks and insert spaces when necessary.\n        if (wsCollapse) {\n          res = ' '\n        } else {\n          res = match[0].replace(lineBreakPat, '')\n        }\n        blocks.push({type: 'break', remaining: res})\n      }\n\n      base = match.index + match[0].length\n      match = multiLineBreakPat.exec(text)\n    }\n    blocks.push(text.substring(base))\n\n    var i, j, k\n    var segments\n    if (skipPat) {\n      segments = []\n      for (i = 0; i < blocks.length; i++) {\n        var bloc = blocks[i]\n        if (typeof bloc !== 'string') {\n          // This is an object.\n          segments.push(bloc)\n        } else {\n          base = 0\n          skipPat.lastIndex = 0\n          match = skipPat.exec(bloc)\n          while(match) {\n            segments.push(bloc.substring(base, match.index))\n            segments.push({type: 'skip', value: match[0]})\n            base = match.index + match[0].length\n            match = skipPat.exec(bloc)\n          }\n          segments.push(bloc.substring(base))\n        }\n      }\n    } else {\n      segments = blocks\n    }\n\n    var chunks = []\n    for (i = 0; i < segments.length; i++) {\n      var segment = segments[i]\n      if (typeof segment !== 'string') {\n        // This is an object.\n        chunks.push(segment)\n      } else {\n        if (wsCollapse) {\n          segment = segment.replace(collapsePat, ' ')\n        }\n\n        var parts = segment.split(re),\n          acc = []\n\n        for (j = 0; j < parts.length; j++) {\n          var x = parts[j]\n          if (mode === 'hard') {\n            for (k = 0; k < x.length; k += wrapLen) {\n              acc.push(x.slice(k, k + wrapLen))\n            }\n          } else { acc.push(x); }\n        }\n        chunks = chunks.concat(acc)\n      }\n    }\n\n    var curLine = 0,\n      curLineLength = start + preservedLinePrefix.length,\n      lines = [ prefix + preservedLinePrefix ],\n      // Holds the \"real length\" (excluding trailing whitespaces) of the\n      // current line if it exceeds `stop`, otherwise 0.\n      // ONLY USED when `wsAll` is true, in `finishOffCurLine()`.\n      bulge = 0,\n      // `cleanLine` is true iff we are at the beginning of an output line. By\n      // \"beginning\" we mean it doesn't contain any non-whitespace char yet.\n      // But its `curLineLength` can be greater than `start`, or even possibly\n      // be greater than `stop`, if `wsStrip` is false.\n      //\n      // Note that a \"clean\" line can still contain skip strings, in addition\n      // to whitespaces.\n      //\n      // This variable is used to allow us strip preceding whitespaces when\n      // `wsStrip` is true, or `wsLine` is true and `preservedLine` is false.\n      cleanLine = true,\n      // `preservedLine` is true iff we are in a preserved input line.\n      //\n      // It's used when `wsLine` is true to (combined with `cleanLine`) decide\n      // whether a whitespace is at the beginning of a preserved input line and\n      // should not be stripped.\n      preservedLine = true,\n      // The current indent prefix for wrapped lines.\n      wrapLinePrefix = wrapLineInitPrefix,\n      remnant\n\n    // Always returns '' if `beforeHardBreak` is true.\n    //\n    // Assumption: Each call of this function is always followed by a `lines.push()` call.\n    //\n    // This function can change the status of `cleanLine`, but we don't modify the value of\n    // `cleanLine` in this function. It's fine because `cleanLine` will be set to the correct\n    // value after the `lines.push()` call following this function call. We also don't update\n    // `curLineLength` when pushing a new line and it's safe for the same reason.\n    function finishOffCurLine (beforeHardBreak) {\n      var str = lines[curLine],\n        idx, ln, rBase\n\n      if (!wsAll) {\n        // Strip all trailing whitespaces past `start`.\n        idx = str.length - 1\n        while (idx >= start && str[idx] === ' ') { idx--; }\n        while (idx >= start && wsPat.test(str[idx])) { idx--; }\n        idx++\n\n        if (idx !== str.length) {\n          lines[curLine] = str.substring(0, idx)\n        }\n\n        if (preservedLine && cleanLine && wsLine && curLineLength > stop) {\n          // Add the remnants to the next line, just like when `wsAll` is true.\n          rBase = str.length - (curLineLength - stop)\n          if (rBase < idx) {\n            // We didn't reach `stop` when stripping due to a bulge.\n            rBase = idx\n          }\n        }\n      } else {\n        // Strip trailing whitespaces exceeding stop.\n        if (curLineLength > stop) {\n          bulge = bulge || stop\n          rBase = str.length - (curLineLength - bulge)\n          lines[curLine] = str.substring(0, rBase)\n        }\n        bulge = 0\n      }\n\n      // Bug: the current implementation of `wrapLineIndent` is buggy: we are not\n      // taking the extra space occupied by the additional indentation into account\n      // when wrapping the line. For example, in \"hard\" mode, we should hard-wrap\n      // long words at `wrapLen - wrapLinePrefix.length` instead of `wrapLen`\n      // and remnants should also be wrapped at `wrapLen - wrapLinePrefix.length`.\n      if (preservedLine) {\n        // This is a preserved line, and the next output line isn't a\n        // preserved line.\n        preservedLine = false\n        if (wrapLineIndentPat) {\n          idx = lines[curLine].substring(start).search(wrapLineIndentPat)\n          if (idx >= 0 && idx + wrapLineIndent > 0) {\n            wrapLinePrefix = new Array(idx + wrapLineIndent + 1).join(' ')\n          } else {\n            wrapLinePrefix = ''\n          }\n        }\n      }\n\n      // Some remnants are left to the next line.\n      if (rBase) {\n        while (rBase + wrapLen < str.length) {\n          if (wsAll) {\n            ln = str.substring(rBase, rBase + wrapLen)\n            lines.push(prefix + wrapLinePrefix + ln)\n          } else {\n            lines.push(prefix + wrapLinePrefix)\n          }\n          rBase += wrapLen\n          curLine++\n        }\n        if (beforeHardBreak) {\n          if (wsAll) {\n            ln = str.substring(rBase)\n            lines.push(prefix + wrapLinePrefix + ln)\n          } else {\n            lines.push(prefix + wrapLinePrefix)\n          }\n          curLine++\n        } else {\n          ln = str.substring(rBase)\n          return wrapLinePrefix + ln\n        }\n      }\n\n      return ''\n    }\n\n    for (i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i]\n\n      if (chunk === '') { continue; }\n\n      if (typeof chunk !== 'string') {\n        if (chunk.type === 'break') {\n          // This is one or more line breaks.\n          // Each entry in `breaks` is just zero or more whitespaces.\n          if (respectLineBreaks !== 'none') {\n            // Note that if `whitespace` is \"collapse\", we still need\n            // to collapse whitespaces in entries of `breaks`.\n            var breaks = chunk.breaks\n            var num = breaks.length - 1\n\n            if (respectLineBreaks === 's') {\n              // This is the most complex scenario. We have to check\n              // the line breaks one by one.\n              for (j = 0; j < num; j++) {\n                if (breaks[j + 1].length < respectNum) {\n                  // This line break should be stripped.\n                  if (wsCollapse) {\n                    breaks[j + 1] = ' '\n                  } else {\n                    breaks[j + 1] = breaks[j] + breaks[j + 1]\n                  }\n                } else {\n                  // This line break should be preserved.\n                  // First finish off the current line.\n                  if (wsAll) {\n                    lines[curLine] += breaks[j]\n                    curLineLength += breaks[j].length\n                  }\n                  finishOffCurLine(true)\n\n                  lines.push(prefix + preservedLinePrefix)\n                  curLine++\n                  curLineLength = start + preservedLinePrefix.length\n\n                  preservedLine = cleanLine = true\n                }\n              }\n              // We are adding to either the existing line (if no line break\n              // is qualified for preservance) or a \"new\" line.\n              if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                if (wsCollapse || (!cleanLine && breaks[num] === '')) {\n                  breaks[num] = ' '\n                }\n                lines[curLine] += breaks[num]\n                curLineLength += breaks[num].length\n              }\n            } else if (respectLineBreaks === 'm' && num < respectNum) {\n              // These line breaks should be stripped.\n              if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                if (wsCollapse) {\n                  chunk = ' '\n                } else {\n                  chunk = breaks.join('')\n                  if (!cleanLine && chunk === '') {\n                    chunk = ' '\n                  }\n                }\n                lines[curLine] += chunk\n                curLineLength += chunk.length\n              }\n            } else { // 'all' || ('m' && num >= respectNum)\n              // These line breaks should be preserved.\n              if (wsStrip) {\n                // Finish off the current line.\n                finishOffCurLine(true)\n\n                for (j = 0; j < num; j++) {\n                  lines.push(prefix + preservedLinePrefix)\n                  curLine++\n                }\n\n                curLineLength = start + preservedLinePrefix.length\n                preservedLine = cleanLine = true\n              } else {\n                if (wsAll || (preservedLine && cleanLine)) {\n                  lines[curLine] += breaks[0]\n                  curLineLength += breaks[0].length\n                }\n\n                for (j = 0; j < num; j++) {\n                  // Finish off the current line.\n                  finishOffCurLine(true)\n\n                  lines.push(prefix + preservedLinePrefix + breaks[j + 1])\n                  curLine++\n                  curLineLength = start + preservedLinePrefix.length + breaks[j + 1].length\n\n                  preservedLine = cleanLine = true\n                }\n              }\n            }\n          } else {\n            // These line breaks should be stripped.\n            if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n              chunk = chunk.remaining\n\n              // Bug: If `wsAll` is true, `cleanLine` is false, and `chunk`\n              // is '', we insert a space to replace the line break. This\n              // space will be preserved even if we are at the end of an\n              // output line, which is wrong behavior. However, I'm not\n              // sure it's worth it to fix this edge case.\n              if (wsCollapse || (!cleanLine && chunk === '')) {\n                chunk = ' '\n              }\n              lines[curLine] += chunk\n              curLineLength += chunk.length\n            }\n          }\n        } else if (chunk.type === 'skip') {\n          // This is a skip string.\n          // Assumption: skip strings don't end with whitespaces.\n          if (curLineLength > stop) {\n            remnant = finishOffCurLine(false)\n\n            lines.push(prefix + wrapLinePrefix)\n            curLine++\n            curLineLength = start + wrapLinePrefix.length\n\n            if (remnant) {\n              lines[curLine] += remnant\n              curLineLength += remnant.length\n            }\n\n            cleanLine = true\n          }\n          lines[curLine] += chunk.value\n        }\n        continue\n      }\n\n      var chunk2\n      while (1) {\n        chunk2 = undefined\n        if (curLineLength + chunk.length > stop &&\n          curLineLength + (chunk2 = chunk.replace(tPat, '')).length > stop &&\n          chunk2 !== '' &&\n          curLineLength > start) {\n          // This line is full, add `chunk` to the next line\n          remnant = finishOffCurLine(false)\n\n          lines.push(prefix + wrapLinePrefix)\n          curLine++\n          curLineLength = start + wrapLinePrefix.length\n\n          if (remnant) {\n            lines[curLine] += remnant\n            curLineLength += remnant.length\n            cleanLine = true\n            continue\n          }\n\n          if (wsStrip || (wsLine && !(preservedLine && cleanLine))) {\n            chunk = chunk.replace(pPat, '')\n          }\n          cleanLine = false\n        } else {\n          // Add `chunk` to this line\n          if (cleanLine) {\n            if (wsStrip || (wsLine && !(preservedLine && cleanLine))) {\n              chunk = chunk.replace(pPat, '')\n              if (chunk !== '') {\n                cleanLine = false\n              }\n            } else {\n              if (nonWsPat.test(chunk)) {\n                cleanLine = false\n              }\n            }\n          }\n        }\n        break\n      }\n      if (wsAll && chunk2 && curLineLength + chunk2.length > stop) {\n        bulge = curLineLength + chunk2.length\n      }\n      lines[curLine] += chunk\n      curLineLength += chunk.length\n    }\n    // Finally, finish off the last line.\n    finishOffCurLine(true)\n    return lines.join(lineBreakStr)\n  }\n}\n\nlinewrap.soft = linewrap\n\nlinewrap.hard = function ( /*start, stop, params*/) {\n  var args = [].slice.call(arguments)\n  var last = args.length - 1\n  if (typeof args[last] === 'object') {\n    args[last].mode = 'hard'\n  } else {\n    args.push({ mode: 'hard' })\n  }\n  return linewrap.apply(null, args)\n}\n\nlinewrap.wrap = function (text /*, start, stop, params*/) {\n  var args = [].slice.call(arguments)\n  args.shift()\n  return linewrap.apply(null, args)(text)\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}