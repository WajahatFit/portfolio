{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst path = require(\"path\");\nconst url = require(\"url\");\nconst fs = require(\"fs-extra\");\nconst errors_1 = require(\"./errors\");\nconst Config = require(\"./config\");\nconst getPackageType = require('get-package-type');\n/**\n * Defines file extension resolution when source files do not have an extension.\n */\n// eslint-disable-next-line camelcase\nconst s_EXTENSIONS = ['.ts', '.js', '.mjs', '.cjs'];\n/**\n * Provides a mechanism to use dynamic import / import() with tsconfig -> module: commonJS as otherwise import() gets\n * transpiled to require().\n */\nconst _importDynamic = new Function('modulePath', 'return import(modulePath)'); // eslint-disable-line no-new-func\n/**\n * Provides a static class with several utility methods to work with Oclif config / plugin to load ESM or CJS Node\n * modules and source files.\n *\n * @author Michael Leahy <support@typhonjs.io> (https://github.com/typhonrt)\n */\n// eslint-disable-next-line unicorn/no-static-only-class\nclass ModuleLoader {\n  /**\n   * Loads and returns a module.\n   *\n   * Uses `getPackageType` to determine if `type` is set to 'module. If so loads '.js' files as ESM otherwise uses\n   * a bare require to load as CJS. Also loads '.mjs' files as ESM.\n   *\n   * Uses dynamic import to load ESM source or require for CommonJS.\n   *\n   * A unique error, ModuleLoadError, combines both CJS and ESM loader module not found errors into a single error that\n   * provides a consistent stack trace and info.\n   *\n   * @param {IConfig|IPlugin} config - Oclif config or plugin config.\n   * @param {string} modulePath - NPM module name or file path to load.\n   *\n   * @returns {Promise<*>} The entire ESM module from dynamic import or CJS module by require.\n   */\n  static async load(config, modulePath) {\n    let filePath;\n    let isESM;\n    try {\n      ({\n        isESM,\n        filePath\n      } = ModuleLoader.resolvePath(config, modulePath));\n      // It is important to await on _importDynamic to catch the error code.\n      return isESM ? await _importDynamic(url.pathToFileURL(filePath)) : require(filePath);\n    } catch (error) {\n      if (error.code === 'MODULE_NOT_FOUND' || error.code === 'ERR_MODULE_NOT_FOUND') {\n        throw new errors_1.ModuleLoadError(`${isESM ? 'import()' : 'require'} failed to load ${filePath || modulePath}`);\n      }\n      throw error;\n    }\n  }\n  /**\n   * Loads a module and returns an object with the module and data about the module.\n   *\n   * Uses `getPackageType` to determine if `type` is set to `module`. If so loads '.js' files as ESM otherwise uses\n   * a bare require to load as CJS. Also loads '.mjs' files as ESM.\n   *\n   * Uses dynamic import to load ESM source or require for CommonJS.\n   *\n   * A unique error, ModuleLoadError, combines both CJS and ESM loader module not found errors into a single error that\n   * provides a consistent stack trace and info.\n   *\n   * @param {IConfig|IPlugin} config - Oclif config or plugin config.\n   * @param {string} modulePath - NPM module name or file path to load.\n   *\n   * @returns {Promise<{isESM: boolean, module: *, filePath: string}>} An object with the loaded module & data including\n   *                                                                   file path and whether the module is ESM.\n   */\n  static async loadWithData(config, modulePath) {\n    let filePath;\n    let isESM;\n    try {\n      ({\n        isESM,\n        filePath\n      } = ModuleLoader.resolvePath(config, modulePath));\n      const module = isESM ? await _importDynamic(url.pathToFileURL(filePath)) : require(filePath);\n      return {\n        isESM,\n        module,\n        filePath\n      };\n    } catch (error) {\n      if (error.code === 'MODULE_NOT_FOUND' || error.code === 'ERR_MODULE_NOT_FOUND') {\n        throw new errors_1.ModuleLoadError(`${isESM ? 'import()' : 'require'} failed to load ${filePath || modulePath}: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n  /**\n   * For `.js` files uses `getPackageType` to determine if `type` is set to `module` in associated `package.json`. If\n   * the `modulePath` provided ends in `.mjs` it is assumed to be ESM.\n   *\n   * @param {string} filePath - File path to test.\n   *\n   * @returns {boolean} The modulePath is an ES Module.\n   * @see https://www.npmjs.com/package/get-package-type\n   */\n  static isPathModule(filePath) {\n    const extension = path.extname(filePath).toLowerCase();\n    switch (extension) {\n      case '.js':\n        return getPackageType.sync(filePath) === 'module';\n      case '.ts':\n        return getPackageType.sync(filePath) === 'module';\n      case '.mjs':\n        return true;\n      default:\n        return false;\n    }\n  }\n  /**\n   * Resolves a modulePath first by `require.resolve` to allow Node to resolve an actual module. If this fails then\n   * the `modulePath` is resolved from the root of the provided config. `Config.tsPath` is used for initial resolution.\n   * If this file path does not exist then several extensions are tried from `s_EXTENSIONS` in order: '.js', '.mjs',\n   * '.cjs'. After a file path has been selected `isPathModule` is used to determine if the file is an ES Module.\n   *\n   * @param {IConfig|IPlugin} config - Oclif config or plugin config.\n   * @param {string} modulePath - File path to load.\n   *\n   * @returns {{isESM: boolean, filePath: string}} An object including file path and whether the module is ESM.\n   */\n  static resolvePath(config, modulePath) {\n    let isESM;\n    let filePath;\n    try {\n      filePath = require.resolve(modulePath);\n      isESM = ModuleLoader.isPathModule(filePath);\n    } catch {\n      filePath = Config.tsPath(config.root, modulePath);\n      let fileExists = false;\n      let isDirectory = false;\n      if (fs.existsSync(filePath)) {\n        fileExists = true;\n        try {\n          if (fs.lstatSync(filePath)?.isDirectory?.()) {\n            fileExists = false;\n            isDirectory = true;\n          }\n        } catch {}\n      }\n      if (!fileExists) {\n        // Try all supported extensions.\n        let foundPath = ModuleLoader.findFile(filePath);\n        if (!foundPath && isDirectory) {\n          // Since filePath is a directory, try looking for index file.\n          foundPath = ModuleLoader.findFile(path.join(filePath, 'index'));\n        }\n        if (foundPath) {\n          filePath = foundPath;\n        }\n      }\n      isESM = ModuleLoader.isPathModule(filePath);\n    }\n    return {\n      isESM,\n      filePath\n    };\n  }\n  /**\n   * Try adding the different extensions from `s_EXTENSIONS` to find the file.\n   *\n   * @param {string} filePath - File path to load.\n   *\n   * @returns {string | null} Modified file path including extension or null if file is not found.\n   */\n  static findFile(filePath) {\n    // eslint-disable-next-line camelcase\n    for (const extension of s_EXTENSIONS) {\n      const testPath = `${filePath}${extension}`;\n      if (fs.existsSync(testPath)) {\n        return testPath;\n      }\n    }\n    return null;\n  }\n}\nexports.default = ModuleLoader;","map":{"version":3,"names":["Object","defineProperty","exports","value","path","require","url","fs","errors_1","Config","getPackageType","s_EXTENSIONS","_importDynamic","Function","ModuleLoader","load","config","modulePath","filePath","isESM","resolvePath","pathToFileURL","error","code","ModuleLoadError","loadWithData","module","message","isPathModule","extension","extname","toLowerCase","sync","resolve","tsPath","root","fileExists","isDirectory","existsSync","lstatSync","foundPath","findFile","join","testPath","default"],"sources":["/Users/wajahatfit/Documents/labs/portfolio/portfolio/node_modules/@oclif/core/lib/module-loader.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = require(\"path\");\nconst url = require(\"url\");\nconst fs = require(\"fs-extra\");\nconst errors_1 = require(\"./errors\");\nconst Config = require(\"./config\");\nconst getPackageType = require('get-package-type');\n/**\n * Defines file extension resolution when source files do not have an extension.\n */\n// eslint-disable-next-line camelcase\nconst s_EXTENSIONS = ['.ts', '.js', '.mjs', '.cjs'];\n/**\n * Provides a mechanism to use dynamic import / import() with tsconfig -> module: commonJS as otherwise import() gets\n * transpiled to require().\n */\nconst _importDynamic = new Function('modulePath', 'return import(modulePath)'); // eslint-disable-line no-new-func\n/**\n * Provides a static class with several utility methods to work with Oclif config / plugin to load ESM or CJS Node\n * modules and source files.\n *\n * @author Michael Leahy <support@typhonjs.io> (https://github.com/typhonrt)\n */\n// eslint-disable-next-line unicorn/no-static-only-class\nclass ModuleLoader {\n    /**\n     * Loads and returns a module.\n     *\n     * Uses `getPackageType` to determine if `type` is set to 'module. If so loads '.js' files as ESM otherwise uses\n     * a bare require to load as CJS. Also loads '.mjs' files as ESM.\n     *\n     * Uses dynamic import to load ESM source or require for CommonJS.\n     *\n     * A unique error, ModuleLoadError, combines both CJS and ESM loader module not found errors into a single error that\n     * provides a consistent stack trace and info.\n     *\n     * @param {IConfig|IPlugin} config - Oclif config or plugin config.\n     * @param {string} modulePath - NPM module name or file path to load.\n     *\n     * @returns {Promise<*>} The entire ESM module from dynamic import or CJS module by require.\n     */\n    static async load(config, modulePath) {\n        let filePath;\n        let isESM;\n        try {\n            ({ isESM, filePath } = ModuleLoader.resolvePath(config, modulePath));\n            // It is important to await on _importDynamic to catch the error code.\n            return isESM ? await _importDynamic(url.pathToFileURL(filePath)) : require(filePath);\n        }\n        catch (error) {\n            if (error.code === 'MODULE_NOT_FOUND' || error.code === 'ERR_MODULE_NOT_FOUND') {\n                throw new errors_1.ModuleLoadError(`${isESM ? 'import()' : 'require'} failed to load ${filePath || modulePath}`);\n            }\n            throw error;\n        }\n    }\n    /**\n     * Loads a module and returns an object with the module and data about the module.\n     *\n     * Uses `getPackageType` to determine if `type` is set to `module`. If so loads '.js' files as ESM otherwise uses\n     * a bare require to load as CJS. Also loads '.mjs' files as ESM.\n     *\n     * Uses dynamic import to load ESM source or require for CommonJS.\n     *\n     * A unique error, ModuleLoadError, combines both CJS and ESM loader module not found errors into a single error that\n     * provides a consistent stack trace and info.\n     *\n     * @param {IConfig|IPlugin} config - Oclif config or plugin config.\n     * @param {string} modulePath - NPM module name or file path to load.\n     *\n     * @returns {Promise<{isESM: boolean, module: *, filePath: string}>} An object with the loaded module & data including\n     *                                                                   file path and whether the module is ESM.\n     */\n    static async loadWithData(config, modulePath) {\n        let filePath;\n        let isESM;\n        try {\n            ({ isESM, filePath } = ModuleLoader.resolvePath(config, modulePath));\n            const module = isESM ? await _importDynamic(url.pathToFileURL(filePath)) : require(filePath);\n            return { isESM, module, filePath };\n        }\n        catch (error) {\n            if (error.code === 'MODULE_NOT_FOUND' || error.code === 'ERR_MODULE_NOT_FOUND') {\n                throw new errors_1.ModuleLoadError(`${isESM ? 'import()' : 'require'} failed to load ${filePath || modulePath}: ${error.message}`);\n            }\n            throw error;\n        }\n    }\n    /**\n     * For `.js` files uses `getPackageType` to determine if `type` is set to `module` in associated `package.json`. If\n     * the `modulePath` provided ends in `.mjs` it is assumed to be ESM.\n     *\n     * @param {string} filePath - File path to test.\n     *\n     * @returns {boolean} The modulePath is an ES Module.\n     * @see https://www.npmjs.com/package/get-package-type\n     */\n    static isPathModule(filePath) {\n        const extension = path.extname(filePath).toLowerCase();\n        switch (extension) {\n            case '.js':\n                return getPackageType.sync(filePath) === 'module';\n            case '.ts':\n                return getPackageType.sync(filePath) === 'module';\n            case '.mjs':\n                return true;\n            default:\n                return false;\n        }\n    }\n    /**\n     * Resolves a modulePath first by `require.resolve` to allow Node to resolve an actual module. If this fails then\n     * the `modulePath` is resolved from the root of the provided config. `Config.tsPath` is used for initial resolution.\n     * If this file path does not exist then several extensions are tried from `s_EXTENSIONS` in order: '.js', '.mjs',\n     * '.cjs'. After a file path has been selected `isPathModule` is used to determine if the file is an ES Module.\n     *\n     * @param {IConfig|IPlugin} config - Oclif config or plugin config.\n     * @param {string} modulePath - File path to load.\n     *\n     * @returns {{isESM: boolean, filePath: string}} An object including file path and whether the module is ESM.\n     */\n    static resolvePath(config, modulePath) {\n        let isESM;\n        let filePath;\n        try {\n            filePath = require.resolve(modulePath);\n            isESM = ModuleLoader.isPathModule(filePath);\n        }\n        catch {\n            filePath = Config.tsPath(config.root, modulePath);\n            let fileExists = false;\n            let isDirectory = false;\n            if (fs.existsSync(filePath)) {\n                fileExists = true;\n                try {\n                    if (fs.lstatSync(filePath)?.isDirectory?.()) {\n                        fileExists = false;\n                        isDirectory = true;\n                    }\n                }\n                catch { }\n            }\n            if (!fileExists) {\n                // Try all supported extensions.\n                let foundPath = ModuleLoader.findFile(filePath);\n                if (!foundPath && isDirectory) {\n                    // Since filePath is a directory, try looking for index file.\n                    foundPath = ModuleLoader.findFile(path.join(filePath, 'index'));\n                }\n                if (foundPath) {\n                    filePath = foundPath;\n                }\n            }\n            isESM = ModuleLoader.isPathModule(filePath);\n        }\n        return { isESM, filePath };\n    }\n    /**\n     * Try adding the different extensions from `s_EXTENSIONS` to find the file.\n     *\n     * @param {string} filePath - File path to load.\n     *\n     * @returns {string | null} Modified file path including extension or null if file is not found.\n     */\n    static findFile(filePath) {\n        // eslint-disable-next-line camelcase\n        for (const extension of s_EXTENSIONS) {\n            const testPath = `${filePath}${extension}`;\n            if (fs.existsSync(testPath)) {\n                return testPath;\n            }\n        }\n        return null;\n    }\n}\nexports.default = ModuleLoader;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}