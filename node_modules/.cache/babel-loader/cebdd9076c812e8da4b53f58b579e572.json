{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validate = void 0;\nconst errors_1 = require(\"./errors\");\nconst util_1 = require(\"../config/util\");\nasync function validate(parse) {\n  function validateArgs() {\n    const maxArgs = parse.input.args.length;\n    if (parse.input.strict && parse.output.argv.length > maxArgs) {\n      const extras = parse.output.argv.slice(maxArgs);\n      throw new errors_1.UnexpectedArgsError({\n        parse,\n        args: extras\n      });\n    }\n    const missingRequiredArgs = [];\n    let hasOptional = false;\n    for (const [index, arg] of parse.input.args.entries()) {\n      if (!arg.required) {\n        hasOptional = true;\n      } else if (hasOptional) {\n        // (required arg) check whether an optional has occurred before\n        // optionals should follow required, not before\n        throw new errors_1.InvalidArgsSpecError({\n          parse,\n          args: parse.input.args\n        });\n      }\n      if (arg.required && !parse.output.argv[index] && parse.output.argv[index] !== 0) {\n        missingRequiredArgs.push(arg);\n      }\n    }\n    if (missingRequiredArgs.length > 0) {\n      throw new errors_1.RequiredArgsError({\n        parse,\n        args: missingRequiredArgs\n      });\n    }\n  }\n  async function validateFlags() {\n    const promises = Object.entries(parse.input.flags).map(async _ref => {\n      let [name, flag] = _ref;\n      const results = [];\n      if (parse.output.flags[name] !== undefined) {\n        results.push(...(await validateRelationships(name, flag)), await validateDependsOn(name, flag.dependsOn ?? []), await validateExclusive(name, flag.exclusive ?? []), await validateExactlyOne(name, flag.exactlyOne ?? []));\n      } else if (flag.required) {\n        results.push({\n          status: 'failed',\n          name,\n          validationFn: 'required',\n          reason: `Missing required flag ${name}`\n        });\n      } else if (flag.exactlyOne && flag.exactlyOne.length > 0) {\n        results.push(validateAcrossFlags(flag));\n      }\n      return results;\n    });\n    const results = (await Promise.all(promises)).flat();\n    const failed = results.filter(r => r.status === 'failed');\n    if (failed.length > 0) throw new errors_1.FailedFlagValidationError({\n      parse,\n      failed\n    });\n  }\n  async function resolveFlags(flags) {\n    const promises = flags.map(async flag => {\n      if (typeof flag === 'string') {\n        return [flag, parse.output.flags[flag]];\n      }\n      const result = await flag.when(parse.output.flags);\n      return result ? [flag.name, parse.output.flags[flag.name]] : null;\n    });\n    const resolved = await Promise.all(promises);\n    return Object.fromEntries(resolved.filter(r => r !== null));\n  }\n  function getPresentFlags(flags) {\n    return Object.keys(flags).reduce((acc, key) => {\n      if (flags[key]) acc.push(key);\n      return acc;\n    }, []);\n  }\n  function validateAcrossFlags(flag) {\n    const base = {\n      name: flag.name,\n      validationFn: 'validateAcrossFlags'\n    };\n    const intersection = Object.entries(parse.input.flags).map(entry => entry[0]) // array of flag names\n    .filter(flagName => parse.output.flags[flagName] !== undefined) // with values\n    .filter(flagName => flag.exactlyOne && flag.exactlyOne.includes(flagName)); // and in the exactlyOne list\n    if (intersection.length === 0) {\n      // the command's exactlyOne may or may not include itself, so we'll use Set to add + de-dupe\n      const deduped = (0, util_1.uniq)(flag.exactlyOne?.map(flag => `--${flag}`) ?? []).join(', ');\n      const reason = `Exactly one of the following must be provided: ${deduped}`;\n      return {\n        ...base,\n        status: 'failed',\n        reason\n      };\n    }\n    return {\n      ...base,\n      status: 'success'\n    };\n  }\n  async function validateExclusive(name, flags) {\n    const base = {\n      name,\n      validationFn: 'validateExclusive'\n    };\n    const resolved = await resolveFlags(flags);\n    const keys = getPresentFlags(resolved);\n    for (const flag of keys) {\n      // do not enforce exclusivity for flags that were defaulted\n      if (parse.output.metadata.flags && parse.output.metadata.flags[flag]?.setFromDefault) continue;\n      if (parse.output.metadata.flags && parse.output.metadata.flags[name]?.setFromDefault) continue;\n      if (parse.output.flags[flag]) {\n        return {\n          ...base,\n          status: 'failed',\n          reason: `--${flag}=${parse.output.flags[flag]} cannot also be provided when using --${name}`\n        };\n      }\n    }\n    return {\n      ...base,\n      status: 'success'\n    };\n  }\n  async function validateExactlyOne(name, flags) {\n    const base = {\n      name,\n      validationFn: 'validateExactlyOne'\n    };\n    const resolved = await resolveFlags(flags);\n    const keys = getPresentFlags(resolved);\n    for (const flag of keys) {\n      if (flag !== name && parse.output.flags[flag]) {\n        return {\n          ...base,\n          status: 'failed',\n          reason: `--${flag} cannot also be provided when using --${name}`\n        };\n      }\n    }\n    return {\n      ...base,\n      status: 'success'\n    };\n  }\n  async function validateDependsOn(name, flags) {\n    const base = {\n      name,\n      validationFn: 'validateDependsOn'\n    };\n    const resolved = await resolveFlags(flags);\n    const foundAll = Object.values(resolved).every(Boolean);\n    if (!foundAll) {\n      const formattedFlags = Object.keys(resolved).map(f => `--${f}`).join(', ');\n      return {\n        ...base,\n        status: 'failed',\n        reason: `All of the following must be provided when using --${name}: ${formattedFlags}`\n      };\n    }\n    return {\n      ...base,\n      status: 'success'\n    };\n  }\n  async function validateSome(name, flags) {\n    const base = {\n      name,\n      validationFn: 'validateSome'\n    };\n    const resolved = await resolveFlags(flags);\n    const foundAtLeastOne = Object.values(resolved).some(Boolean);\n    if (!foundAtLeastOne) {\n      const formattedFlags = Object.keys(resolved).map(f => `--${f}`).join(', ');\n      return {\n        ...base,\n        status: 'failed',\n        reason: `One of the following must be provided when using --${name}: ${formattedFlags}`\n      };\n    }\n    return {\n      ...base,\n      status: 'success'\n    };\n  }\n  async function validateRelationships(name, flag) {\n    if (!flag.relationships) return [];\n    const results = await Promise.all(flag.relationships.map(async relationship => {\n      const flags = relationship.flags ?? [];\n      const results = [];\n      switch (relationship.type) {\n        case 'all':\n          results.push(await validateDependsOn(name, flags));\n          break;\n        case 'some':\n          results.push(await validateSome(name, flags));\n          break;\n        case 'none':\n          results.push(await validateExclusive(name, flags));\n          break;\n        default:\n          break;\n      }\n      return results;\n    }));\n    return results.flat();\n  }\n  validateArgs();\n  await validateFlags();\n}\nexports.validate = validate;","map":{"version":3,"names":["Object","defineProperty","exports","value","validate","errors_1","require","util_1","parse","validateArgs","maxArgs","input","args","length","strict","output","argv","extras","slice","UnexpectedArgsError","missingRequiredArgs","hasOptional","index","arg","entries","required","InvalidArgsSpecError","push","RequiredArgsError","validateFlags","promises","flags","map","name","flag","results","undefined","validateRelationships","validateDependsOn","dependsOn","validateExclusive","exclusive","validateExactlyOne","exactlyOne","status","validationFn","reason","validateAcrossFlags","Promise","all","flat","failed","filter","r","FailedFlagValidationError","resolveFlags","result","when","resolved","fromEntries","getPresentFlags","keys","reduce","acc","key","base","intersection","entry","flagName","includes","deduped","uniq","join","metadata","setFromDefault","foundAll","values","every","Boolean","formattedFlags","f","validateSome","foundAtLeastOne","some","relationships","relationship","type"],"sources":["/Users/wajahatfit/Documents/labs/portfolio/portfolio/node_modules/@oclif/core/lib/parser/validate.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validate = void 0;\nconst errors_1 = require(\"./errors\");\nconst util_1 = require(\"../config/util\");\nasync function validate(parse) {\n    function validateArgs() {\n        const maxArgs = parse.input.args.length;\n        if (parse.input.strict && parse.output.argv.length > maxArgs) {\n            const extras = parse.output.argv.slice(maxArgs);\n            throw new errors_1.UnexpectedArgsError({ parse, args: extras });\n        }\n        const missingRequiredArgs = [];\n        let hasOptional = false;\n        for (const [index, arg] of parse.input.args.entries()) {\n            if (!arg.required) {\n                hasOptional = true;\n            }\n            else if (hasOptional) {\n                // (required arg) check whether an optional has occurred before\n                // optionals should follow required, not before\n                throw new errors_1.InvalidArgsSpecError({ parse, args: parse.input.args });\n            }\n            if (arg.required && !parse.output.argv[index] && parse.output.argv[index] !== 0) {\n                missingRequiredArgs.push(arg);\n            }\n        }\n        if (missingRequiredArgs.length > 0) {\n            throw new errors_1.RequiredArgsError({ parse, args: missingRequiredArgs });\n        }\n    }\n    async function validateFlags() {\n        const promises = Object.entries(parse.input.flags).map(async ([name, flag]) => {\n            const results = [];\n            if (parse.output.flags[name] !== undefined) {\n                results.push(...await validateRelationships(name, flag), await validateDependsOn(name, flag.dependsOn ?? []), await validateExclusive(name, flag.exclusive ?? []), await validateExactlyOne(name, flag.exactlyOne ?? []));\n            }\n            else if (flag.required) {\n                results.push({ status: 'failed', name, validationFn: 'required', reason: `Missing required flag ${name}` });\n            }\n            else if (flag.exactlyOne && flag.exactlyOne.length > 0) {\n                results.push(validateAcrossFlags(flag));\n            }\n            return results;\n        });\n        const results = (await Promise.all(promises)).flat();\n        const failed = results.filter(r => r.status === 'failed');\n        if (failed.length > 0)\n            throw new errors_1.FailedFlagValidationError({ parse, failed });\n    }\n    async function resolveFlags(flags) {\n        const promises = flags.map(async (flag) => {\n            if (typeof flag === 'string') {\n                return [flag, parse.output.flags[flag]];\n            }\n            const result = await flag.when(parse.output.flags);\n            return result ? [flag.name, parse.output.flags[flag.name]] : null;\n        });\n        const resolved = await Promise.all(promises);\n        return Object.fromEntries(resolved.filter(r => r !== null));\n    }\n    function getPresentFlags(flags) {\n        return Object.keys(flags).reduce((acc, key) => {\n            if (flags[key])\n                acc.push(key);\n            return acc;\n        }, []);\n    }\n    function validateAcrossFlags(flag) {\n        const base = { name: flag.name, validationFn: 'validateAcrossFlags' };\n        const intersection = Object.entries(parse.input.flags)\n            .map(entry => entry[0]) // array of flag names\n            .filter(flagName => parse.output.flags[flagName] !== undefined) // with values\n            .filter(flagName => flag.exactlyOne && flag.exactlyOne.includes(flagName)); // and in the exactlyOne list\n        if (intersection.length === 0) {\n            // the command's exactlyOne may or may not include itself, so we'll use Set to add + de-dupe\n            const deduped = (0, util_1.uniq)(flag.exactlyOne?.map(flag => `--${flag}`) ?? []).join(', ');\n            const reason = `Exactly one of the following must be provided: ${deduped}`;\n            return { ...base, status: 'failed', reason };\n        }\n        return { ...base, status: 'success' };\n    }\n    async function validateExclusive(name, flags) {\n        const base = { name, validationFn: 'validateExclusive' };\n        const resolved = await resolveFlags(flags);\n        const keys = getPresentFlags(resolved);\n        for (const flag of keys) {\n            // do not enforce exclusivity for flags that were defaulted\n            if (parse.output.metadata.flags && parse.output.metadata.flags[flag]?.setFromDefault)\n                continue;\n            if (parse.output.metadata.flags && parse.output.metadata.flags[name]?.setFromDefault)\n                continue;\n            if (parse.output.flags[flag]) {\n                return { ...base, status: 'failed', reason: `--${flag}=${parse.output.flags[flag]} cannot also be provided when using --${name}` };\n            }\n        }\n        return { ...base, status: 'success' };\n    }\n    async function validateExactlyOne(name, flags) {\n        const base = { name, validationFn: 'validateExactlyOne' };\n        const resolved = await resolveFlags(flags);\n        const keys = getPresentFlags(resolved);\n        for (const flag of keys) {\n            if (flag !== name && parse.output.flags[flag]) {\n                return { ...base, status: 'failed', reason: `--${flag} cannot also be provided when using --${name}` };\n            }\n        }\n        return { ...base, status: 'success' };\n    }\n    async function validateDependsOn(name, flags) {\n        const base = { name, validationFn: 'validateDependsOn' };\n        const resolved = await resolveFlags(flags);\n        const foundAll = Object.values(resolved).every(Boolean);\n        if (!foundAll) {\n            const formattedFlags = Object.keys(resolved).map(f => `--${f}`).join(', ');\n            return { ...base, status: 'failed', reason: `All of the following must be provided when using --${name}: ${formattedFlags}` };\n        }\n        return { ...base, status: 'success' };\n    }\n    async function validateSome(name, flags) {\n        const base = { name, validationFn: 'validateSome' };\n        const resolved = await resolveFlags(flags);\n        const foundAtLeastOne = Object.values(resolved).some(Boolean);\n        if (!foundAtLeastOne) {\n            const formattedFlags = Object.keys(resolved).map(f => `--${f}`).join(', ');\n            return { ...base, status: 'failed', reason: `One of the following must be provided when using --${name}: ${formattedFlags}` };\n        }\n        return { ...base, status: 'success' };\n    }\n    async function validateRelationships(name, flag) {\n        if (!flag.relationships)\n            return [];\n        const results = await Promise.all(flag.relationships.map(async (relationship) => {\n            const flags = relationship.flags ?? [];\n            const results = [];\n            switch (relationship.type) {\n                case 'all':\n                    results.push(await validateDependsOn(name, flags));\n                    break;\n                case 'some':\n                    results.push(await validateSome(name, flags));\n                    break;\n                case 'none':\n                    results.push(await validateExclusive(name, flags));\n                    break;\n                default:\n                    break;\n            }\n            return results;\n        }));\n        return results.flat();\n    }\n    validateArgs();\n    await validateFlags();\n}\nexports.validate = validate;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}