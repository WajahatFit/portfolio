{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DocOpts = void 0;\n/**\n * DocOpts - See http://docopt.org/.\n *\n * flag.exclusive: groups elements when one of the mutually exclusive cases is a required flag: (--apple | --orange)\n * flag.exclusive: groups elements when none of the mutually exclusive cases is required (optional flags): [--apple | --orange]\n * flag.dependsOn: specifies that if one element is present, then another one is required: (--apple --orange)\n *\n * @example\n *  {\n *      name: 'classnames',\n *      required: true,\n *      exclusive: ['suitenames']\n *      ...\n *  },{\n *      name: 'suitenames',\n *      type: 'array'\n *      required: true\n *      ...\n *  }\n *\n *  Results in:\n *      Usage: <%= command.id %> (-n <string> | -s <array>)\n *\n * @example\n *  {\n *      name: 'classnames',\n *      ...\n *      excludes: ['suitenames']\n *  },{\n *      name: 'suitenames',\n *      ...\n *  }\n *\n *  Results in:\n *      Usage: <%= command.id %> [-n <string> | -s <string>]\n *\n * @example\n *  {\n *      name: 'classnames',\n *      ...\n *      dependsOn: ['suitenames']\n *  },{\n *      name: 'suitenames',\n *      type: 'flag'\n *      ...\n *  }\n *\n *  Results in:\n *      Usage: <%= command.id %> (-n <string> -s)\n *\n * TODO:\n *  - Support nesting, eg:\n *      Usage: my_program (--either-this <and-that> | <or-this>)\n *      Usage: my_program [(<one-argument> <another-argument>)]\n *\n */\nclass DocOpts {\n  constructor(cmd) {\n    this.cmd = cmd;\n    // Create a new map with references to the flags that we can manipulate.\n    this.flagMap = {};\n    this.flagList = Object.entries(cmd.flags || {}).filter(_ref => {\n      let [_, flag] = _ref;\n      return !flag.hidden;\n    }).map(_ref2 => {\n      let [name, flag] = _ref2;\n      this.flagMap[name] = flag;\n      return flag;\n    });\n  }\n  static generate(cmd) {\n    return new DocOpts(cmd).toString();\n  }\n  toString() {\n    const opts = this.cmd.id === '.' || this.cmd.id === '' ? [] : ['<%= command.id %>'];\n    if (this.cmd.args) {\n      const a = this.cmd.args?.map(arg => `[${arg.name.toUpperCase()}]`) || [];\n      opts.push(...a);\n    }\n    try {\n      opts.push(...Object.values(this.groupFlagElements()));\n    } catch {\n      // If there is an error, just return no usage so we don't fail command help.\n      opts.push(...this.flagList.map(flag => {\n        const name = flag.char ? `-${flag.char}` : `--${flag.name}`;\n        if (flag.type === 'boolean') return name;\n        return `${name}=<value>`;\n      }));\n    }\n    return opts.join(' ');\n  }\n  groupFlagElements() {\n    const elementMap = {};\n    // Generate all doc opt elements for combining\n    // Show required flags first\n    this.generateElements(elementMap, this.flagList.filter(flag => flag.required));\n    // Then show optional flags\n    this.generateElements(elementMap, this.flagList.filter(flag => !flag.required));\n    for (const flag of this.flagList) {\n      if (Array.isArray(flag.dependsOn)) {\n        this.combineElementsToFlag(elementMap, flag.name, flag.dependsOn, ' ');\n      }\n      if (Array.isArray(flag.exclusive)) {\n        this.combineElementsToFlag(elementMap, flag.name, flag.exclusive, ' | ');\n      }\n    }\n    // Since combineElementsToFlag deletes the references in this.flags when it combines\n    // them, this will go through the remaining list of uncombined elements.\n    for (const remainingFlagName of Object.keys(this.flagMap)) {\n      const remainingFlag = this.flagMap[remainingFlagName] || {};\n      if (!remainingFlag.required) {\n        elementMap[remainingFlag.name] = `[${elementMap[remainingFlag.name] || ''}]`;\n      }\n    }\n    return elementMap;\n  }\n  combineElementsToFlag(elementMap, flagName, flagNames, unionString) {\n    if (!this.flagMap[flagName]) {\n      return;\n    }\n    let isRequired = this.flagMap[flagName]?.required;\n    if (typeof isRequired !== 'boolean' || !isRequired) {\n      isRequired = flagNames.reduce((required, toCombine) => required || this.flagMap[toCombine]?.required || false, false);\n    }\n    for (const toCombine of flagNames) {\n      elementMap[flagName] = `${elementMap[flagName] || ''}${unionString}${elementMap[toCombine] || ''}`;\n      // We handled this flag, don't handle it again\n      delete elementMap[toCombine];\n      delete this.flagMap[toCombine];\n    }\n    if (isRequired) {\n      elementMap[flagName] = `(${elementMap[flagName] || ''})`;\n    } else {\n      elementMap[flagName] = `[${elementMap[flagName] || ''}]`;\n    }\n    // We handled this flag, don't handle it again\n    delete this.flagMap[flagName];\n  }\n  // eslint-disable-next-line default-param-last\n  generateElements() {\n    let elementMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let flagGroups = arguments.length > 1 ? arguments[1] : undefined;\n    const elementStrs = [];\n    for (const flag of flagGroups) {\n      let type = '';\n      // not all flags have short names\n      const flagName = flag.char ? `-${flag.char}` : `--${flag.name}`;\n      if (flag.type === 'option') {\n        type = flag.options ? ` ${flag.options.join('|')}` : ' <value>';\n      }\n      const element = `${flagName}${type}`;\n      elementMap[flag.name] = element;\n      elementStrs.push(element);\n    }\n    return elementStrs;\n  }\n}\nexports.DocOpts = DocOpts;","map":{"version":3,"names":["Object","defineProperty","exports","value","DocOpts","constructor","cmd","flagMap","flagList","entries","flags","filter","_","flag","hidden","map","name","generate","toString","opts","id","args","a","arg","toUpperCase","push","values","groupFlagElements","char","type","join","elementMap","generateElements","required","Array","isArray","dependsOn","combineElementsToFlag","exclusive","remainingFlagName","keys","remainingFlag","flagName","flagNames","unionString","isRequired","reduce","toCombine","flagGroups","elementStrs","options","element"],"sources":["/Users/wajahatfit/Documents/labs/portfolio/portfolio/node_modules/@oclif/core/lib/help/docopts.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DocOpts = void 0;\n/**\n * DocOpts - See http://docopt.org/.\n *\n * flag.exclusive: groups elements when one of the mutually exclusive cases is a required flag: (--apple | --orange)\n * flag.exclusive: groups elements when none of the mutually exclusive cases is required (optional flags): [--apple | --orange]\n * flag.dependsOn: specifies that if one element is present, then another one is required: (--apple --orange)\n *\n * @example\n *  {\n *      name: 'classnames',\n *      required: true,\n *      exclusive: ['suitenames']\n *      ...\n *  },{\n *      name: 'suitenames',\n *      type: 'array'\n *      required: true\n *      ...\n *  }\n *\n *  Results in:\n *      Usage: <%= command.id %> (-n <string> | -s <array>)\n *\n * @example\n *  {\n *      name: 'classnames',\n *      ...\n *      excludes: ['suitenames']\n *  },{\n *      name: 'suitenames',\n *      ...\n *  }\n *\n *  Results in:\n *      Usage: <%= command.id %> [-n <string> | -s <string>]\n *\n * @example\n *  {\n *      name: 'classnames',\n *      ...\n *      dependsOn: ['suitenames']\n *  },{\n *      name: 'suitenames',\n *      type: 'flag'\n *      ...\n *  }\n *\n *  Results in:\n *      Usage: <%= command.id %> (-n <string> -s)\n *\n * TODO:\n *  - Support nesting, eg:\n *      Usage: my_program (--either-this <and-that> | <or-this>)\n *      Usage: my_program [(<one-argument> <another-argument>)]\n *\n */\nclass DocOpts {\n    constructor(cmd) {\n        this.cmd = cmd;\n        // Create a new map with references to the flags that we can manipulate.\n        this.flagMap = {};\n        this.flagList = Object.entries(cmd.flags || {})\n            .filter(([_, flag]) => !flag.hidden)\n            .map(([name, flag]) => {\n            this.flagMap[name] = flag;\n            return flag;\n        });\n    }\n    static generate(cmd) {\n        return new DocOpts(cmd).toString();\n    }\n    toString() {\n        const opts = this.cmd.id === '.' || this.cmd.id === '' ? [] : ['<%= command.id %>'];\n        if (this.cmd.args) {\n            const a = this.cmd.args?.map(arg => `[${arg.name.toUpperCase()}]`) || [];\n            opts.push(...a);\n        }\n        try {\n            opts.push(...Object.values(this.groupFlagElements()));\n        }\n        catch {\n            // If there is an error, just return no usage so we don't fail command help.\n            opts.push(...this.flagList.map(flag => {\n                const name = flag.char ? `-${flag.char}` : `--${flag.name}`;\n                if (flag.type === 'boolean')\n                    return name;\n                return `${name}=<value>`;\n            }));\n        }\n        return opts.join(' ');\n    }\n    groupFlagElements() {\n        const elementMap = {};\n        // Generate all doc opt elements for combining\n        // Show required flags first\n        this.generateElements(elementMap, this.flagList.filter(flag => flag.required));\n        // Then show optional flags\n        this.generateElements(elementMap, this.flagList.filter(flag => !flag.required));\n        for (const flag of this.flagList) {\n            if (Array.isArray(flag.dependsOn)) {\n                this.combineElementsToFlag(elementMap, flag.name, flag.dependsOn, ' ');\n            }\n            if (Array.isArray(flag.exclusive)) {\n                this.combineElementsToFlag(elementMap, flag.name, flag.exclusive, ' | ');\n            }\n        }\n        // Since combineElementsToFlag deletes the references in this.flags when it combines\n        // them, this will go through the remaining list of uncombined elements.\n        for (const remainingFlagName of Object.keys(this.flagMap)) {\n            const remainingFlag = this.flagMap[remainingFlagName] || {};\n            if (!remainingFlag.required) {\n                elementMap[remainingFlag.name] = `[${elementMap[remainingFlag.name] || ''}]`;\n            }\n        }\n        return elementMap;\n    }\n    combineElementsToFlag(elementMap, flagName, flagNames, unionString) {\n        if (!this.flagMap[flagName]) {\n            return;\n        }\n        let isRequired = this.flagMap[flagName]?.required;\n        if (typeof isRequired !== 'boolean' || !isRequired) {\n            isRequired = flagNames.reduce((required, toCombine) => required || this.flagMap[toCombine]?.required || false, false);\n        }\n        for (const toCombine of flagNames) {\n            elementMap[flagName] = `${elementMap[flagName] || ''}${unionString}${elementMap[toCombine] || ''}`;\n            // We handled this flag, don't handle it again\n            delete elementMap[toCombine];\n            delete this.flagMap[toCombine];\n        }\n        if (isRequired) {\n            elementMap[flagName] = `(${elementMap[flagName] || ''})`;\n        }\n        else {\n            elementMap[flagName] = `[${elementMap[flagName] || ''}]`;\n        }\n        // We handled this flag, don't handle it again\n        delete this.flagMap[flagName];\n    }\n    // eslint-disable-next-line default-param-last\n    generateElements(elementMap = {}, flagGroups) {\n        const elementStrs = [];\n        for (const flag of flagGroups) {\n            let type = '';\n            // not all flags have short names\n            const flagName = flag.char ? `-${flag.char}` : `--${flag.name}`;\n            if (flag.type === 'option') {\n                type = flag.options ? ` ${flag.options.join('|')}` : ' <value>';\n            }\n            const element = `${flagName}${type}`;\n            elementMap[flag.name] = element;\n            elementStrs.push(element);\n        }\n        return elementStrs;\n    }\n}\nexports.DocOpts = DocOpts;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}