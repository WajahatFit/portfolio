{"ast":null,"code":"\"use strict\";\n\n// tslint:disable interface-over-type-literal\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\nconst deps_1 = require(\"./deps\");\n// eslint-disable-next-line new-cap\nconst m = (0, deps_1.default)()\n// eslint-disable-next-line node/no-missing-require\n.add('errors', () => require('./errors'))\n// eslint-disable-next-line node/no-missing-require\n.add('util', () => require('./util'));\nlet debug;\ntry {\n  // eslint-disable-next-line no-negated-condition\n  debug = process.env.CLI_FLAGS_DEBUG !== '1' ? () => {} : require('debug')('../parser');\n} catch {\n  debug = () => {};\n}\nconst readStdin = async () => {\n  const {\n    stdin\n  } = process;\n  let result;\n  if (stdin.isTTY || stdin.isTTY === undefined) return result;\n  result = '';\n  stdin.setEncoding('utf8');\n  for await (const chunk of stdin) {\n    result += chunk;\n  }\n  return result;\n};\nclass Parser {\n  constructor(input) {\n    this.input = input;\n    this.raw = [];\n    const {\n      pickBy\n    } = m.util;\n    this.context = input.context || {};\n    this.argv = [...input.argv];\n    this._setNames();\n    this.booleanFlags = pickBy(input.flags, f => f.type === 'boolean');\n    this.flagAliases = Object.fromEntries(Object.values(input.flags).flatMap(flag => {\n      return (flag.aliases ?? []).map(a => [a, flag]);\n    }));\n    this.metaData = {};\n  }\n  async parse() {\n    this._debugInput();\n    const findLongFlag = arg => {\n      const name = arg.slice(2);\n      if (this.input.flags[name]) {\n        return name;\n      }\n      if (this.flagAliases[name]) {\n        return this.flagAliases[name].name;\n      }\n      if (arg.startsWith('--no-')) {\n        const flag = this.booleanFlags[arg.slice(5)];\n        if (flag && flag.allowNo) return flag.name;\n      }\n    };\n    const findShortFlag = arg => {\n      return Object.keys(this.input.flags).find(k => this.input.flags[k].char === arg[1]);\n    };\n    const parseFlag = arg => {\n      const long = arg.startsWith('--');\n      const name = long ? findLongFlag(arg) : findShortFlag(arg);\n      if (!name) {\n        const i = arg.indexOf('=');\n        if (i !== -1) {\n          const sliced = arg.slice(i + 1);\n          this.argv.unshift(sliced);\n          const equalsParsed = parseFlag(arg.slice(0, i));\n          if (!equalsParsed) {\n            this.argv.shift();\n          }\n          return equalsParsed;\n        }\n        return false;\n      }\n      const flag = this.input.flags[name];\n      if (flag.type === 'option') {\n        this.currentFlag = flag;\n        const input = long || arg.length < 3 ? this.argv.shift() : arg.slice(arg[2] === '=' ? 3 : 2);\n        if (typeof input !== 'string') {\n          throw new m.errors.CLIError(`Flag --${name} expects a value`);\n        }\n        this.raw.push({\n          type: 'flag',\n          flag: flag.name,\n          input\n        });\n      } else {\n        this.raw.push({\n          type: 'flag',\n          flag: flag.name,\n          input: arg\n        });\n        // push the rest of the short characters back on the stack\n        if (!long && arg.length > 2) {\n          this.argv.unshift(`-${arg.slice(2)}`);\n        }\n      }\n      return true;\n    };\n    let parsingFlags = true;\n    while (this.argv.length > 0) {\n      const input = this.argv.shift();\n      if (parsingFlags && input.startsWith('-') && input !== '-') {\n        // attempt to parse as arg\n        if (this.input['--'] !== false && input === '--') {\n          parsingFlags = false;\n          continue;\n        }\n        if (parseFlag(input)) {\n          continue;\n        }\n        // not actually a flag if it reaches here so parse as an arg\n      }\n\n      if (parsingFlags && this.currentFlag && this.currentFlag.multiple) {\n        this.raw.push({\n          type: 'flag',\n          flag: this.currentFlag.name,\n          input\n        });\n        continue;\n      }\n      // not a flag, parse as arg\n      const arg = this.input.args[this._argTokens.length];\n      if (arg) arg.input = input;\n      this.raw.push({\n        type: 'arg',\n        input\n      });\n    }\n    const argv = await this._argv();\n    const args = this._args(argv);\n    const flags = await this._flags();\n    this._debugOutput(argv, args, flags);\n    return {\n      args,\n      argv,\n      flags,\n      raw: this.raw,\n      metadata: this.metaData\n    };\n  }\n  _args(argv) {\n    const args = {};\n    for (let i = 0; i < this.input.args.length; i++) {\n      const arg = this.input.args[i];\n      args[arg.name] = argv[i];\n    }\n    return args;\n  }\n  async _flags() {\n    const flags = {};\n    this.metaData.flags = {};\n    for (const token of this._flagTokens) {\n      const flag = this.input.flags[token.flag];\n      if (!flag) throw new m.errors.CLIError(`Unexpected flag ${token.flag}`);\n      if (flag.type === 'boolean') {\n        if (token.input === `--no-${flag.name}`) {\n          flags[token.flag] = false;\n        } else {\n          flags[token.flag] = true;\n        }\n        // eslint-disable-next-line no-await-in-loop\n        flags[token.flag] = await flag.parse(flags[token.flag], this.context, flag);\n      } else {\n        const input = token.input;\n        this._validateOptions(flag, input);\n        // eslint-disable-next-line no-await-in-loop\n        const value = flag.parse ? await flag.parse(input, this.context, flag) : input;\n        if (flag.multiple) {\n          flags[token.flag] = flags[token.flag] || [];\n          flags[token.flag].push(value);\n        } else {\n          flags[token.flag] = value;\n        }\n      }\n    }\n    for (const k of Object.keys(this.input.flags)) {\n      const flag = this.input.flags[k];\n      if (flags[k]) continue;\n      if (flag.env) {\n        const input = process.env[flag.env];\n        if (flag.type === 'option') {\n          if (input) {\n            this._validateOptions(flag, input);\n            // eslint-disable-next-line no-await-in-loop\n            flags[k] = await flag.parse(input, this.context, flag);\n          }\n        } else if (flag.type === 'boolean') {\n          // eslint-disable-next-line no-negated-condition\n          flags[k] = input !== undefined ? ['true', 'TRUE', '1', 'yes', 'YES', 'y', 'Y'].includes(input) : false;\n        }\n      }\n      if (!(k in flags) && flag.default !== undefined) {\n        this.metaData.flags[k] = {\n          setFromDefault: true\n        };\n        // eslint-disable-next-line no-await-in-loop\n        const defaultValue = typeof flag.default === 'function' ? await flag.default({\n          options: flag,\n          flags,\n          ...this.context\n        }) : flag.default;\n        flags[k] = defaultValue;\n      }\n    }\n    return flags;\n  }\n  _validateOptions(flag, input) {\n    if (flag.options && !flag.options.includes(input)) throw new m.errors.FlagInvalidOptionError(flag, input);\n  }\n  async _argv() {\n    const args = [];\n    const tokens = this._argTokens;\n    let stdinRead = false;\n    for (let i = 0; i < Math.max(this.input.args.length, tokens.length); i++) {\n      const token = tokens[i];\n      const arg = this.input.args[i];\n      if (token) {\n        if (arg) {\n          if (arg.options && !arg.options.includes(token.input)) {\n            throw new m.errors.ArgInvalidOptionError(arg, token.input);\n          }\n          // eslint-disable-next-line no-await-in-loop\n          args[i] = await arg.parse(token.input);\n        } else {\n          args[i] = token.input;\n        }\n      } else if (!arg.ignoreStdin && !stdinRead) {\n        // eslint-disable-next-line no-await-in-loop\n        let stdin = await readStdin();\n        if (stdin) {\n          stdin = stdin.trim();\n          args[i] = stdin;\n        }\n        stdinRead = true;\n      }\n      if (!args[i] && arg?.default !== undefined) {\n        if (typeof arg.default === 'function') {\n          // eslint-disable-next-line no-await-in-loop\n          const f = await arg.default();\n          args[i] = f;\n        } else {\n          args[i] = arg.default;\n        }\n      }\n    }\n    return args;\n  }\n  _debugOutput(args, flags, argv) {\n    if (argv.length > 0) {\n      debug('argv: %o', argv);\n    }\n    if (Object.keys(args).length > 0) {\n      debug('args: %o', args);\n    }\n    if (Object.keys(flags).length > 0) {\n      debug('flags: %o', flags);\n    }\n  }\n  _debugInput() {\n    debug('input: %s', this.argv.join(' '));\n    if (this.input.args.length > 0) {\n      debug('available args: %s', this.input.args.map(a => a.name).join(' '));\n    }\n    if (Object.keys(this.input.flags).length === 0) return;\n    debug('available flags: %s', Object.keys(this.input.flags).map(f => `--${f}`).join(' '));\n  }\n  get _argTokens() {\n    return this.raw.filter(o => o.type === 'arg');\n  }\n  get _flagTokens() {\n    return this.raw.filter(o => o.type === 'flag');\n  }\n  _setNames() {\n    for (const k of Object.keys(this.input.flags)) {\n      this.input.flags[k].name = k;\n    }\n  }\n}\nexports.Parser = Parser;","map":{"version":3,"names":["Object","defineProperty","exports","value","Parser","deps_1","require","m","default","add","debug","process","env","CLI_FLAGS_DEBUG","readStdin","stdin","result","isTTY","undefined","setEncoding","chunk","constructor","input","raw","pickBy","util","context","argv","_setNames","booleanFlags","flags","f","type","flagAliases","fromEntries","values","flatMap","flag","aliases","map","a","metaData","parse","_debugInput","findLongFlag","arg","name","slice","startsWith","allowNo","findShortFlag","keys","find","k","char","parseFlag","long","i","indexOf","sliced","unshift","equalsParsed","shift","currentFlag","length","errors","CLIError","push","parsingFlags","multiple","args","_argTokens","_argv","_args","_flags","_debugOutput","metadata","token","_flagTokens","_validateOptions","includes","setFromDefault","defaultValue","options","FlagInvalidOptionError","tokens","stdinRead","Math","max","ArgInvalidOptionError","ignoreStdin","trim","join","filter","o"],"sources":["/Users/wajahatfit/Documents/labs/portfolio/portfolio/node_modules/@oclif/core/lib/parser/parse.js"],"sourcesContent":["\"use strict\";\n// tslint:disable interface-over-type-literal\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst deps_1 = require(\"./deps\");\n// eslint-disable-next-line new-cap\nconst m = (0, deps_1.default)()\n    // eslint-disable-next-line node/no-missing-require\n    .add('errors', () => require('./errors'))\n    // eslint-disable-next-line node/no-missing-require\n    .add('util', () => require('./util'));\nlet debug;\ntry {\n    // eslint-disable-next-line no-negated-condition\n    debug = process.env.CLI_FLAGS_DEBUG !== '1' ? () => { } : require('debug')('../parser');\n}\ncatch {\n    debug = () => { };\n}\nconst readStdin = async () => {\n    const { stdin } = process;\n    let result;\n    if (stdin.isTTY || stdin.isTTY === undefined)\n        return result;\n    result = '';\n    stdin.setEncoding('utf8');\n    for await (const chunk of stdin) {\n        result += chunk;\n    }\n    return result;\n};\nclass Parser {\n    constructor(input) {\n        this.input = input;\n        this.raw = [];\n        const { pickBy } = m.util;\n        this.context = input.context || {};\n        this.argv = [...input.argv];\n        this._setNames();\n        this.booleanFlags = pickBy(input.flags, f => f.type === 'boolean');\n        this.flagAliases = Object.fromEntries(Object.values(input.flags).flatMap(flag => {\n            return (flag.aliases ?? []).map(a => [a, flag]);\n        }));\n        this.metaData = {};\n    }\n    async parse() {\n        this._debugInput();\n        const findLongFlag = (arg) => {\n            const name = arg.slice(2);\n            if (this.input.flags[name]) {\n                return name;\n            }\n            if (this.flagAliases[name]) {\n                return this.flagAliases[name].name;\n            }\n            if (arg.startsWith('--no-')) {\n                const flag = this.booleanFlags[arg.slice(5)];\n                if (flag && flag.allowNo)\n                    return flag.name;\n            }\n        };\n        const findShortFlag = (arg) => {\n            return Object.keys(this.input.flags).find(k => this.input.flags[k].char === arg[1]);\n        };\n        const parseFlag = (arg) => {\n            const long = arg.startsWith('--');\n            const name = long ? findLongFlag(arg) : findShortFlag(arg);\n            if (!name) {\n                const i = arg.indexOf('=');\n                if (i !== -1) {\n                    const sliced = arg.slice(i + 1);\n                    this.argv.unshift(sliced);\n                    const equalsParsed = parseFlag(arg.slice(0, i));\n                    if (!equalsParsed) {\n                        this.argv.shift();\n                    }\n                    return equalsParsed;\n                }\n                return false;\n            }\n            const flag = this.input.flags[name];\n            if (flag.type === 'option') {\n                this.currentFlag = flag;\n                const input = long || arg.length < 3 ? this.argv.shift() : arg.slice(arg[2] === '=' ? 3 : 2);\n                if (typeof input !== 'string') {\n                    throw new m.errors.CLIError(`Flag --${name} expects a value`);\n                }\n                this.raw.push({ type: 'flag', flag: flag.name, input });\n            }\n            else {\n                this.raw.push({ type: 'flag', flag: flag.name, input: arg });\n                // push the rest of the short characters back on the stack\n                if (!long && arg.length > 2) {\n                    this.argv.unshift(`-${arg.slice(2)}`);\n                }\n            }\n            return true;\n        };\n        let parsingFlags = true;\n        while (this.argv.length > 0) {\n            const input = this.argv.shift();\n            if (parsingFlags && input.startsWith('-') && input !== '-') {\n                // attempt to parse as arg\n                if (this.input['--'] !== false && input === '--') {\n                    parsingFlags = false;\n                    continue;\n                }\n                if (parseFlag(input)) {\n                    continue;\n                }\n                // not actually a flag if it reaches here so parse as an arg\n            }\n            if (parsingFlags && this.currentFlag && this.currentFlag.multiple) {\n                this.raw.push({ type: 'flag', flag: this.currentFlag.name, input });\n                continue;\n            }\n            // not a flag, parse as arg\n            const arg = this.input.args[this._argTokens.length];\n            if (arg)\n                arg.input = input;\n            this.raw.push({ type: 'arg', input });\n        }\n        const argv = await this._argv();\n        const args = this._args(argv);\n        const flags = await this._flags();\n        this._debugOutput(argv, args, flags);\n        return {\n            args,\n            argv,\n            flags,\n            raw: this.raw,\n            metadata: this.metaData,\n        };\n    }\n    _args(argv) {\n        const args = {};\n        for (let i = 0; i < this.input.args.length; i++) {\n            const arg = this.input.args[i];\n            args[arg.name] = argv[i];\n        }\n        return args;\n    }\n    async _flags() {\n        const flags = {};\n        this.metaData.flags = {};\n        for (const token of this._flagTokens) {\n            const flag = this.input.flags[token.flag];\n            if (!flag)\n                throw new m.errors.CLIError(`Unexpected flag ${token.flag}`);\n            if (flag.type === 'boolean') {\n                if (token.input === `--no-${flag.name}`) {\n                    flags[token.flag] = false;\n                }\n                else {\n                    flags[token.flag] = true;\n                }\n                // eslint-disable-next-line no-await-in-loop\n                flags[token.flag] = await flag.parse(flags[token.flag], this.context, flag);\n            }\n            else {\n                const input = token.input;\n                this._validateOptions(flag, input);\n                // eslint-disable-next-line no-await-in-loop\n                const value = flag.parse ? await flag.parse(input, this.context, flag) : input;\n                if (flag.multiple) {\n                    flags[token.flag] = flags[token.flag] || [];\n                    flags[token.flag].push(value);\n                }\n                else {\n                    flags[token.flag] = value;\n                }\n            }\n        }\n        for (const k of Object.keys(this.input.flags)) {\n            const flag = this.input.flags[k];\n            if (flags[k])\n                continue;\n            if (flag.env) {\n                const input = process.env[flag.env];\n                if (flag.type === 'option') {\n                    if (input) {\n                        this._validateOptions(flag, input);\n                        // eslint-disable-next-line no-await-in-loop\n                        flags[k] = await flag.parse(input, this.context, flag);\n                    }\n                }\n                else if (flag.type === 'boolean') {\n                    // eslint-disable-next-line no-negated-condition\n                    flags[k] = input !== undefined ? ['true', 'TRUE', '1', 'yes', 'YES', 'y', 'Y'].includes(input) : false;\n                }\n            }\n            if (!(k in flags) && flag.default !== undefined) {\n                this.metaData.flags[k] = { setFromDefault: true };\n                // eslint-disable-next-line no-await-in-loop\n                const defaultValue = (typeof flag.default === 'function' ? await flag.default({ options: flag, flags, ...this.context }) : flag.default);\n                flags[k] = defaultValue;\n            }\n        }\n        return flags;\n    }\n    _validateOptions(flag, input) {\n        if (flag.options && !flag.options.includes(input))\n            throw new m.errors.FlagInvalidOptionError(flag, input);\n    }\n    async _argv() {\n        const args = [];\n        const tokens = this._argTokens;\n        let stdinRead = false;\n        for (let i = 0; i < Math.max(this.input.args.length, tokens.length); i++) {\n            const token = tokens[i];\n            const arg = this.input.args[i];\n            if (token) {\n                if (arg) {\n                    if (arg.options && !arg.options.includes(token.input)) {\n                        throw new m.errors.ArgInvalidOptionError(arg, token.input);\n                    }\n                    // eslint-disable-next-line no-await-in-loop\n                    args[i] = await arg.parse(token.input);\n                }\n                else {\n                    args[i] = token.input;\n                }\n            }\n            else if (!arg.ignoreStdin && !stdinRead) {\n                // eslint-disable-next-line no-await-in-loop\n                let stdin = await readStdin();\n                if (stdin) {\n                    stdin = stdin.trim();\n                    args[i] = stdin;\n                }\n                stdinRead = true;\n            }\n            if (!args[i] && arg?.default !== undefined) {\n                if (typeof arg.default === 'function') {\n                    // eslint-disable-next-line no-await-in-loop\n                    const f = await arg.default();\n                    args[i] = f;\n                }\n                else {\n                    args[i] = arg.default;\n                }\n            }\n        }\n        return args;\n    }\n    _debugOutput(args, flags, argv) {\n        if (argv.length > 0) {\n            debug('argv: %o', argv);\n        }\n        if (Object.keys(args).length > 0) {\n            debug('args: %o', args);\n        }\n        if (Object.keys(flags).length > 0) {\n            debug('flags: %o', flags);\n        }\n    }\n    _debugInput() {\n        debug('input: %s', this.argv.join(' '));\n        if (this.input.args.length > 0) {\n            debug('available args: %s', this.input.args.map(a => a.name).join(' '));\n        }\n        if (Object.keys(this.input.flags).length === 0)\n            return;\n        debug('available flags: %s', Object.keys(this.input.flags)\n            .map(f => `--${f}`)\n            .join(' '));\n    }\n    get _argTokens() {\n        return this.raw.filter(o => o.type === 'arg');\n    }\n    get _flagTokens() {\n        return this.raw.filter(o => o.type === 'flag');\n    }\n    _setNames() {\n        for (const k of Object.keys(this.input.flags)) {\n            this.input.flags[k].name = k;\n        }\n    }\n}\nexports.Parser = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}