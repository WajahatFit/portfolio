{"ast":null,"code":"const _Terminal = require('./terminal');\nconst _BarElement = require('./generic-bar');\nconst _options = require('./options');\nconst _EventEmitter = require('events');\n\n// Progress-Bar constructor\nmodule.exports = class MultiBar extends _EventEmitter {\n  constructor(options, preset) {\n    super();\n\n    // list of bars\n    this.bars = [];\n\n    // parse+store options\n    this.options = _options.parse(options, preset);\n\n    // disable synchronous updates\n    this.options.synchronousUpdate = false;\n\n    // store terminal instance\n    this.terminal = this.options.terminal ? this.options.terminal : new _Terminal(this.options.stream);\n\n    // the update timer\n    this.timer = null;\n\n    // progress bar active ?\n    this.isActive = false;\n\n    // update interval\n    this.schedulingRate = this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule;\n\n    // logging output buffer\n    this.loggingBuffer = [];\n\n    // callback used for gracefulExit\n    this.sigintCallback = null;\n  }\n\n  // add a new bar to the stack\n  create(total, startValue, payload) {\n    let barOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    // create new bar element\n    const bar = new _BarElement(Object.assign({}, this.options, barOptions));\n\n    // store bar\n    this.bars.push(bar);\n\n    // progress updates are only visible in TTY mode!\n    if (this.options.noTTYOutput === false && this.terminal.isTTY() === false) {\n      return bar;\n    }\n\n    // add handler to restore cursor settings (stop the bar) on SIGINT/SIGTERM ?\n    if (this.sigintCallback === null && this.options.gracefulExit) {\n      this.sigintCallback = this.stop.bind(this);\n      process.once('SIGINT', this.sigintCallback);\n      process.once('SIGTERM', this.sigintCallback);\n    }\n\n    // multiprogress already active ?\n    if (!this.isActive) {\n      // hide the cursor ?\n      if (this.options.hideCursor === true) {\n        this.terminal.cursor(false);\n      }\n\n      // disable line wrapping ?\n      if (this.options.linewrap === false) {\n        this.terminal.lineWrapping(false);\n      }\n\n      // initialize update timer\n      this.timer = setTimeout(this.update.bind(this), this.schedulingRate);\n    }\n\n    // set flag\n    this.isActive = true;\n\n    // start progress bar\n    bar.start(total, startValue, payload);\n\n    // trigger event\n    this.emit('start');\n\n    // return new instance\n    return bar;\n  }\n\n  // remove a bar from the stack\n  remove(bar) {\n    // find element\n    const index = this.bars.indexOf(bar);\n\n    // element found ?\n    if (index < 0) {\n      return false;\n    }\n\n    // remove element\n    this.bars.splice(index, 1);\n\n    // force update\n    this.update();\n\n    // clear bottom\n    this.terminal.newline();\n    this.terminal.clearBottom();\n    return true;\n  }\n\n  // internal update routine\n  update() {\n    // stop timer\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n\n    // trigger event\n    this.emit('update-pre');\n\n    // reset cursor\n    this.terminal.cursorRelativeReset();\n\n    // trigger event\n    this.emit('redraw-pre');\n\n    // content within logging buffer ?\n    if (this.loggingBuffer.length > 0) {\n      this.terminal.clearLine();\n\n      // flush logging buffer and write content to terminal\n      while (this.loggingBuffer.length > 0) {\n        this.terminal.write(this.loggingBuffer.shift(), true);\n      }\n    }\n\n    // update each bar\n    for (let i = 0; i < this.bars.length; i++) {\n      // add new line ?\n      if (i > 0) {\n        this.terminal.newline();\n      }\n\n      // render\n      this.bars[i].render();\n    }\n\n    // trigger event\n    this.emit('redraw-post');\n\n    // add new line in notty mode!\n    if (this.options.noTTYOutput && this.terminal.isTTY() === false) {\n      this.terminal.newline();\n      this.terminal.newline();\n    }\n\n    // next update\n    this.timer = setTimeout(this.update.bind(this), this.schedulingRate);\n\n    // trigger event\n    this.emit('update-post');\n\n    // stop if stopOnComplete and all bars stopped\n    if (this.options.stopOnComplete && !this.bars.find(bar => bar.isActive)) {\n      this.stop();\n    }\n  }\n  stop() {\n    // stop timer\n    clearTimeout(this.timer);\n    this.timer = null;\n\n    // remove sigint listener\n    if (this.sigintCallback) {\n      process.removeListener('SIGINT', this.sigintCallback);\n      process.removeListener('SIGTERM', this.sigintCallback);\n      this.sigintCallback = null;\n    }\n\n    // set flag\n    this.isActive = false;\n\n    // cursor hidden ?\n    if (this.options.hideCursor === true) {\n      this.terminal.cursor(true);\n    }\n\n    // re-enable line wrpaping ?\n    if (this.options.linewrap === false) {\n      this.terminal.lineWrapping(true);\n    }\n\n    // reset cursor\n    this.terminal.cursorRelativeReset();\n\n    // trigger event\n    this.emit('stop-pre-clear');\n\n    // clear line on complete ?\n    if (this.options.clearOnComplete) {\n      // clear all bars\n      this.terminal.clearBottom();\n\n      // or show final progress ?\n    } else {\n      // update each bar\n      for (let i = 0; i < this.bars.length; i++) {\n        // add new line ?\n        if (i > 0) {\n          this.terminal.newline();\n        }\n\n        // trigger final rendering\n        this.bars[i].render();\n\n        // stop\n        this.bars[i].stop();\n      }\n\n      // new line on complete\n      this.terminal.newline();\n    }\n\n    // trigger event\n    this.emit('stop');\n  }\n  log(s) {\n    // push content into logging buffer\n    this.loggingBuffer.push(s);\n  }\n};","map":{"version":3,"names":["_Terminal","require","_BarElement","_options","_EventEmitter","module","exports","MultiBar","constructor","options","preset","bars","parse","synchronousUpdate","terminal","stream","timer","isActive","schedulingRate","isTTY","throttleTime","notTTYSchedule","loggingBuffer","sigintCallback","create","total","startValue","payload","barOptions","bar","Object","assign","push","noTTYOutput","gracefulExit","stop","bind","process","once","hideCursor","cursor","linewrap","lineWrapping","setTimeout","update","start","emit","remove","index","indexOf","splice","newline","clearBottom","clearTimeout","cursorRelativeReset","length","clearLine","write","shift","i","render","stopOnComplete","find","removeListener","clearOnComplete","log","s"],"sources":["/Users/wajahatfit/Documents/labs/portfolio/portfolio/node_modules/cli-progress/lib/multi-bar.js"],"sourcesContent":["const _Terminal = require('./terminal');\nconst _BarElement = require('./generic-bar');\nconst _options = require('./options');\nconst _EventEmitter = require('events');\n\n// Progress-Bar constructor\nmodule.exports = class MultiBar extends _EventEmitter{\n\n    constructor(options, preset){\n        super();\n\n        // list of bars\n        this.bars = [];\n\n        // parse+store options\n        this.options = _options.parse(options, preset);\n\n        // disable synchronous updates\n        this.options.synchronousUpdate = false;\n\n        // store terminal instance\n        this.terminal = (this.options.terminal) ? this.options.terminal : new _Terminal(this.options.stream);\n\n        // the update timer\n        this.timer = null;\n\n        // progress bar active ?\n        this.isActive = false;\n\n        // update interval\n        this.schedulingRate = (this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule);\n\n        // logging output buffer\n        this.loggingBuffer = [];\n\n        // callback used for gracefulExit\n        this.sigintCallback = null;\n    }\n\n    // add a new bar to the stack\n    create(total, startValue, payload, barOptions={}){\n        // create new bar element\n        const bar = new _BarElement(Object.assign({}, this.options, barOptions));\n\n        // store bar\n        this.bars.push(bar);\n\n        // progress updates are only visible in TTY mode!\n        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false){\n            return bar;\n        }\n\n        // add handler to restore cursor settings (stop the bar) on SIGINT/SIGTERM ?\n        if (this.sigintCallback === null && this.options.gracefulExit){\n            this.sigintCallback = this.stop.bind(this);\n            process.once('SIGINT', this.sigintCallback);\n            process.once('SIGTERM', this.sigintCallback);\n        }\n        \n        // multiprogress already active ?\n        if (!this.isActive){\n            // hide the cursor ?\n            if (this.options.hideCursor === true){\n                this.terminal.cursor(false);\n            }\n\n            // disable line wrapping ?\n            if (this.options.linewrap === false){\n                this.terminal.lineWrapping(false);\n            }\n    \n            // initialize update timer\n            this.timer = setTimeout(this.update.bind(this), this.schedulingRate);\n        }\n\n        // set flag\n        this.isActive = true;\n\n        // start progress bar\n        bar.start(total, startValue, payload);\n\n        // trigger event\n        this.emit('start');\n\n        // return new instance\n        return bar;\n    }\n\n    // remove a bar from the stack\n    remove(bar){\n        // find element\n        const index = this.bars.indexOf(bar);\n\n        // element found ?\n        if (index < 0){\n            return false;\n        }\n\n        // remove element\n        this.bars.splice(index, 1);\n\n        // force update\n        this.update();\n\n        // clear bottom\n        this.terminal.newline();\n        this.terminal.clearBottom();\n\n        return true;\n    }\n\n    // internal update routine\n    update(){\n        // stop timer\n        if (this.timer){\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n\n        // trigger event\n        this.emit('update-pre');\n        \n        // reset cursor\n        this.terminal.cursorRelativeReset();\n\n        // trigger event\n        this.emit('redraw-pre');\n\n        // content within logging buffer ?\n        if (this.loggingBuffer.length > 0){\n            this.terminal.clearLine();\n\n            // flush logging buffer and write content to terminal\n            while (this.loggingBuffer.length > 0){\n                this.terminal.write(this.loggingBuffer.shift(), true);\n            }\n        }\n\n        // update each bar\n        for (let i=0; i< this.bars.length; i++){\n            // add new line ?\n            if (i > 0){\n                this.terminal.newline();\n            }\n\n            // render\n            this.bars[i].render();\n        }\n\n        // trigger event\n        this.emit('redraw-post');\n\n        // add new line in notty mode!\n        if (this.options.noTTYOutput && this.terminal.isTTY() === false){\n            this.terminal.newline();\n            this.terminal.newline();\n        }\n\n        // next update\n        this.timer = setTimeout(this.update.bind(this), this.schedulingRate);\n\n        // trigger event\n        this.emit('update-post');\n\n        // stop if stopOnComplete and all bars stopped\n        if (this.options.stopOnComplete && !this.bars.find(bar => bar.isActive)) {\n            this.stop();\n        }\n    }\n\n    stop(){\n\n        // stop timer\n        clearTimeout(this.timer);\n        this.timer = null;\n\n        // remove sigint listener\n        if (this.sigintCallback){\n            process.removeListener('SIGINT', this.sigintCallback);\n            process.removeListener('SIGTERM', this.sigintCallback);\n            this.sigintCallback = null;\n        }\n\n        // set flag\n        this.isActive = false;\n\n        // cursor hidden ?\n        if (this.options.hideCursor === true){\n            this.terminal.cursor(true);\n        }\n\n        // re-enable line wrpaping ?\n        if (this.options.linewrap === false){\n            this.terminal.lineWrapping(true);\n        }\n\n        // reset cursor\n        this.terminal.cursorRelativeReset();\n\n        // trigger event\n        this.emit('stop-pre-clear');\n\n        // clear line on complete ?\n        if (this.options.clearOnComplete){\n            // clear all bars\n            this.terminal.clearBottom();\n            \n        // or show final progress ?\n        }else{\n            // update each bar\n            for (let i=0; i< this.bars.length; i++){\n                // add new line ?\n                if (i > 0){\n                    this.terminal.newline();\n                }\n\n                // trigger final rendering\n                this.bars[i].render();\n\n                // stop\n                this.bars[i].stop();\n            }\n\n            // new line on complete\n            this.terminal.newline();\n        }\n\n        // trigger event\n        this.emit('stop');\n    }\n\n    log(s){\n        // push content into logging buffer\n        this.loggingBuffer.push(s);\n    }\n}\n"],"mappings":"AAAA,MAAMA,SAAS,GAAGC,OAAO,CAAC,YAAY,CAAC;AACvC,MAAMC,WAAW,GAAGD,OAAO,CAAC,eAAe,CAAC;AAC5C,MAAME,QAAQ,GAAGF,OAAO,CAAC,WAAW,CAAC;AACrC,MAAMG,aAAa,GAAGH,OAAO,CAAC,QAAQ,CAAC;;AAEvC;AACAI,MAAM,CAACC,OAAO,GAAG,MAAMC,QAAQ,SAASH,aAAa;EAEjDI,WAAW,CAACC,OAAO,EAAEC,MAAM,EAAC;IACxB,KAAK,EAAE;;IAEP;IACA,IAAI,CAACC,IAAI,GAAG,EAAE;;IAEd;IACA,IAAI,CAACF,OAAO,GAAGN,QAAQ,CAACS,KAAK,CAACH,OAAO,EAAEC,MAAM,CAAC;;IAE9C;IACA,IAAI,CAACD,OAAO,CAACI,iBAAiB,GAAG,KAAK;;IAEtC;IACA,IAAI,CAACC,QAAQ,GAAI,IAAI,CAACL,OAAO,CAACK,QAAQ,GAAI,IAAI,CAACL,OAAO,CAACK,QAAQ,GAAG,IAAId,SAAS,CAAC,IAAI,CAACS,OAAO,CAACM,MAAM,CAAC;;IAEpG;IACA,IAAI,CAACC,KAAK,GAAG,IAAI;;IAEjB;IACA,IAAI,CAACC,QAAQ,GAAG,KAAK;;IAErB;IACA,IAAI,CAACC,cAAc,GAAI,IAAI,CAACJ,QAAQ,CAACK,KAAK,EAAE,GAAG,IAAI,CAACV,OAAO,CAACW,YAAY,GAAG,IAAI,CAACX,OAAO,CAACY,cAAe;;IAEvG;IACA,IAAI,CAACC,aAAa,GAAG,EAAE;;IAEvB;IACA,IAAI,CAACC,cAAc,GAAG,IAAI;EAC9B;;EAEA;EACAC,MAAM,CAACC,KAAK,EAAEC,UAAU,EAAEC,OAAO,EAAgB;IAAA,IAAdC,UAAU,uEAAC,CAAC,CAAC;IAC5C;IACA,MAAMC,GAAG,GAAG,IAAI3B,WAAW,CAAC4B,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACtB,OAAO,EAAEmB,UAAU,CAAC,CAAC;;IAExE;IACA,IAAI,CAACjB,IAAI,CAACqB,IAAI,CAACH,GAAG,CAAC;;IAEnB;IACA,IAAI,IAAI,CAACpB,OAAO,CAACwB,WAAW,KAAK,KAAK,IAAI,IAAI,CAACnB,QAAQ,CAACK,KAAK,EAAE,KAAK,KAAK,EAAC;MACtE,OAAOU,GAAG;IACd;;IAEA;IACA,IAAI,IAAI,CAACN,cAAc,KAAK,IAAI,IAAI,IAAI,CAACd,OAAO,CAACyB,YAAY,EAAC;MAC1D,IAAI,CAACX,cAAc,GAAG,IAAI,CAACY,IAAI,CAACC,IAAI,CAAC,IAAI,CAAC;MAC1CC,OAAO,CAACC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAACf,cAAc,CAAC;MAC3Cc,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,IAAI,CAACf,cAAc,CAAC;IAChD;;IAEA;IACA,IAAI,CAAC,IAAI,CAACN,QAAQ,EAAC;MACf;MACA,IAAI,IAAI,CAACR,OAAO,CAAC8B,UAAU,KAAK,IAAI,EAAC;QACjC,IAAI,CAACzB,QAAQ,CAAC0B,MAAM,CAAC,KAAK,CAAC;MAC/B;;MAEA;MACA,IAAI,IAAI,CAAC/B,OAAO,CAACgC,QAAQ,KAAK,KAAK,EAAC;QAChC,IAAI,CAAC3B,QAAQ,CAAC4B,YAAY,CAAC,KAAK,CAAC;MACrC;;MAEA;MACA,IAAI,CAAC1B,KAAK,GAAG2B,UAAU,CAAC,IAAI,CAACC,MAAM,CAACR,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAClB,cAAc,CAAC;IACxE;;IAEA;IACA,IAAI,CAACD,QAAQ,GAAG,IAAI;;IAEpB;IACAY,GAAG,CAACgB,KAAK,CAACpB,KAAK,EAAEC,UAAU,EAAEC,OAAO,CAAC;;IAErC;IACA,IAAI,CAACmB,IAAI,CAAC,OAAO,CAAC;;IAElB;IACA,OAAOjB,GAAG;EACd;;EAEA;EACAkB,MAAM,CAAClB,GAAG,EAAC;IACP;IACA,MAAMmB,KAAK,GAAG,IAAI,CAACrC,IAAI,CAACsC,OAAO,CAACpB,GAAG,CAAC;;IAEpC;IACA,IAAImB,KAAK,GAAG,CAAC,EAAC;MACV,OAAO,KAAK;IAChB;;IAEA;IACA,IAAI,CAACrC,IAAI,CAACuC,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;;IAE1B;IACA,IAAI,CAACJ,MAAM,EAAE;;IAEb;IACA,IAAI,CAAC9B,QAAQ,CAACqC,OAAO,EAAE;IACvB,IAAI,CAACrC,QAAQ,CAACsC,WAAW,EAAE;IAE3B,OAAO,IAAI;EACf;;EAEA;EACAR,MAAM,GAAE;IACJ;IACA,IAAI,IAAI,CAAC5B,KAAK,EAAC;MACXqC,YAAY,CAAC,IAAI,CAACrC,KAAK,CAAC;MACxB,IAAI,CAACA,KAAK,GAAG,IAAI;IACrB;;IAEA;IACA,IAAI,CAAC8B,IAAI,CAAC,YAAY,CAAC;;IAEvB;IACA,IAAI,CAAChC,QAAQ,CAACwC,mBAAmB,EAAE;;IAEnC;IACA,IAAI,CAACR,IAAI,CAAC,YAAY,CAAC;;IAEvB;IACA,IAAI,IAAI,CAACxB,aAAa,CAACiC,MAAM,GAAG,CAAC,EAAC;MAC9B,IAAI,CAACzC,QAAQ,CAAC0C,SAAS,EAAE;;MAEzB;MACA,OAAO,IAAI,CAAClC,aAAa,CAACiC,MAAM,GAAG,CAAC,EAAC;QACjC,IAAI,CAACzC,QAAQ,CAAC2C,KAAK,CAAC,IAAI,CAACnC,aAAa,CAACoC,KAAK,EAAE,EAAE,IAAI,CAAC;MACzD;IACJ;;IAEA;IACA,KAAK,IAAIC,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAE,IAAI,CAAChD,IAAI,CAAC4C,MAAM,EAAEI,CAAC,EAAE,EAAC;MACnC;MACA,IAAIA,CAAC,GAAG,CAAC,EAAC;QACN,IAAI,CAAC7C,QAAQ,CAACqC,OAAO,EAAE;MAC3B;;MAEA;MACA,IAAI,CAACxC,IAAI,CAACgD,CAAC,CAAC,CAACC,MAAM,EAAE;IACzB;;IAEA;IACA,IAAI,CAACd,IAAI,CAAC,aAAa,CAAC;;IAExB;IACA,IAAI,IAAI,CAACrC,OAAO,CAACwB,WAAW,IAAI,IAAI,CAACnB,QAAQ,CAACK,KAAK,EAAE,KAAK,KAAK,EAAC;MAC5D,IAAI,CAACL,QAAQ,CAACqC,OAAO,EAAE;MACvB,IAAI,CAACrC,QAAQ,CAACqC,OAAO,EAAE;IAC3B;;IAEA;IACA,IAAI,CAACnC,KAAK,GAAG2B,UAAU,CAAC,IAAI,CAACC,MAAM,CAACR,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAClB,cAAc,CAAC;;IAEpE;IACA,IAAI,CAAC4B,IAAI,CAAC,aAAa,CAAC;;IAExB;IACA,IAAI,IAAI,CAACrC,OAAO,CAACoD,cAAc,IAAI,CAAC,IAAI,CAAClD,IAAI,CAACmD,IAAI,CAACjC,GAAG,IAAIA,GAAG,CAACZ,QAAQ,CAAC,EAAE;MACrE,IAAI,CAACkB,IAAI,EAAE;IACf;EACJ;EAEAA,IAAI,GAAE;IAEF;IACAkB,YAAY,CAAC,IAAI,CAACrC,KAAK,CAAC;IACxB,IAAI,CAACA,KAAK,GAAG,IAAI;;IAEjB;IACA,IAAI,IAAI,CAACO,cAAc,EAAC;MACpBc,OAAO,CAAC0B,cAAc,CAAC,QAAQ,EAAE,IAAI,CAACxC,cAAc,CAAC;MACrDc,OAAO,CAAC0B,cAAc,CAAC,SAAS,EAAE,IAAI,CAACxC,cAAc,CAAC;MACtD,IAAI,CAACA,cAAc,GAAG,IAAI;IAC9B;;IAEA;IACA,IAAI,CAACN,QAAQ,GAAG,KAAK;;IAErB;IACA,IAAI,IAAI,CAACR,OAAO,CAAC8B,UAAU,KAAK,IAAI,EAAC;MACjC,IAAI,CAACzB,QAAQ,CAAC0B,MAAM,CAAC,IAAI,CAAC;IAC9B;;IAEA;IACA,IAAI,IAAI,CAAC/B,OAAO,CAACgC,QAAQ,KAAK,KAAK,EAAC;MAChC,IAAI,CAAC3B,QAAQ,CAAC4B,YAAY,CAAC,IAAI,CAAC;IACpC;;IAEA;IACA,IAAI,CAAC5B,QAAQ,CAACwC,mBAAmB,EAAE;;IAEnC;IACA,IAAI,CAACR,IAAI,CAAC,gBAAgB,CAAC;;IAE3B;IACA,IAAI,IAAI,CAACrC,OAAO,CAACuD,eAAe,EAAC;MAC7B;MACA,IAAI,CAAClD,QAAQ,CAACsC,WAAW,EAAE;;MAE/B;IACA,CAAC,MAAI;MACD;MACA,KAAK,IAAIO,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAE,IAAI,CAAChD,IAAI,CAAC4C,MAAM,EAAEI,CAAC,EAAE,EAAC;QACnC;QACA,IAAIA,CAAC,GAAG,CAAC,EAAC;UACN,IAAI,CAAC7C,QAAQ,CAACqC,OAAO,EAAE;QAC3B;;QAEA;QACA,IAAI,CAACxC,IAAI,CAACgD,CAAC,CAAC,CAACC,MAAM,EAAE;;QAErB;QACA,IAAI,CAACjD,IAAI,CAACgD,CAAC,CAAC,CAACxB,IAAI,EAAE;MACvB;;MAEA;MACA,IAAI,CAACrB,QAAQ,CAACqC,OAAO,EAAE;IAC3B;;IAEA;IACA,IAAI,CAACL,IAAI,CAAC,MAAM,CAAC;EACrB;EAEAmB,GAAG,CAACC,CAAC,EAAC;IACF;IACA,IAAI,CAAC5C,aAAa,CAACU,IAAI,CAACkC,CAAC,CAAC;EAC9B;AACJ,CAAC"},"metadata":{},"sourceType":"script"}