{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HelpFormatter = void 0;\nconst Chalk = require(\"chalk\");\nconst indent = require(\"indent-string\");\nconst stripAnsi = require(\"strip-ansi\");\nconst screen_1 = require(\"../screen\");\nconst util_1 = require(\"./util\");\nconst width = require('string-width');\nconst widestLine = require('widest-line');\nconst wrap = require('wrap-ansi');\nconst {\n  bold\n} = Chalk;\nclass HelpFormatter {\n  constructor(config) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.indentSpacing = 2;\n    this.config = config;\n    this.opts = {\n      maxWidth: screen_1.stdtermwidth,\n      ...opts\n    };\n    this.render = (0, util_1.template)(this);\n  }\n  /**\n   * Wrap text according to `opts.maxWidth` which is typically set to the terminal width. All text\n   * will be rendered before bring wrapped, otherwise it could mess up the lengths.\n   *\n   * A terminal will automatically wrap text, so this method is primarily used for indented\n   * text. For indented text, specify the indentation so it is taken into account during wrapping.\n   *\n   * Here is an example of wrapping with indentation.\n   * ```\n   * <------ terminal window width ------>\n   * <---------- no indentation --------->\n   * This is my text that will be wrapped\n   * once it passes maxWidth.\n   *\n   * <- indent -><------ text space ----->\n   *             This is my text that will\n   *             be wrapped once it passes\n   *             maxWidth.\n   *\n   * <-- indent not taken into account ->\n   *             This is my text that will\n   * be wrapped\n   *             once it passes maxWidth.\n   * ```\n   * @param body the text to wrap\n   * @param spacing the indentation size to subtract from the terminal width\n   * @returns the formatted wrapped text\n   */\n  wrap(body) {\n    let spacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.indentSpacing;\n    return wrap(this.render(body), this.opts.maxWidth - spacing, {\n      hard: true\n    });\n  }\n  /**\n   * Indent by `this.indentSpacing`. The text should be wrap based on terminal width before indented.\n   *\n   * In order to call indent multiple times on the same set or text, the caller must wrap based on\n   * the number of times the text has been indented. For example.\n   *\n   * ```javascript\n   * const body = `main line\\n${indent(wrap('indented example line', 4))}`\n   * const header = 'SECTION'\n   * console.log(`${header}\\n${indent(wrap(body))}`\n   * ```\n   * will output\n   * ```\n   * SECTION\n   *   main line\n   *     indented example line\n   * ```\n   *\n   * If the terminal width was 24 and the `4` was not provided in the first wrap, it would like like the following.\n   * ```\n   * SECTION\n   *   main line\n   *     indented example\n   *   line\n   * ```\n   * @param body the text to indent\n   * @param spacing the final number of spaces this text will be indented\n   * @return the formatted indented text\n   */\n  indent(body) {\n    let spacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.indentSpacing;\n    return indent(body, spacing);\n  }\n  renderList(input, opts) {\n    if (input.length === 0) {\n      return '';\n    }\n    const renderMultiline = () => {\n      let output = '';\n      for (let [left, right] of input) {\n        if (!left && !right) continue;\n        if (left) {\n          if (opts.stripAnsi) left = stripAnsi(left);\n          output += this.wrap(left.trim(), opts.indentation);\n        }\n        if (right) {\n          if (opts.stripAnsi) right = stripAnsi(right);\n          output += '\\n';\n          output += this.indent(this.wrap(right.trim(), opts.indentation + 2), 4);\n        }\n        output += '\\n\\n';\n      }\n      return output.trim();\n    };\n    if (opts.multiline) return renderMultiline();\n    const maxLength = widestLine(input.map(i => i[0]).join('\\n'));\n    let output = '';\n    let spacer = opts.spacer || '\\n';\n    let cur = '';\n    for (const [left, r] of input) {\n      let right = r;\n      if (cur) {\n        output += spacer;\n        output += cur;\n      }\n      cur = left || '';\n      if (opts.stripAnsi) cur = stripAnsi(cur);\n      if (!right) {\n        cur = cur.trim();\n        continue;\n      }\n      if (opts.stripAnsi) right = stripAnsi(right);\n      right = this.wrap(right.trim(), opts.indentation + maxLength + 2);\n      const [first, ...lines] = right.split('\\n').map(s => s.trim());\n      cur += ' '.repeat(maxLength - width(cur) + 2);\n      cur += first;\n      if (lines.length === 0) {\n        continue;\n      }\n      // if we start putting too many lines down, render in multiline format\n      if (lines.length > 4) return renderMultiline();\n      // if spacer is not defined, separate all rows with a newline\n      if (!opts.spacer) spacer = '\\n';\n      cur += '\\n';\n      cur += this.indent(lines.join('\\n'), maxLength + 2);\n    }\n    if (cur) {\n      output += spacer;\n      output += cur;\n    }\n    return output.trim();\n  }\n  section(header, body) {\n    // Always render template strings with the provided render function before wrapping and indenting\n    let newBody;\n    if (typeof body === 'string') {\n      newBody = this.render(body);\n    } else if (Array.isArray(body)) {\n      newBody = body.map(entry => {\n        if ('name' in entry) {\n          const tableEntry = entry;\n          return [this.render(tableEntry.name), this.render(tableEntry.description)];\n        }\n        const [left, right] = entry;\n        return [this.render(left), right && this.render(right)];\n      });\n    } else if ('header' in body) {\n      return this.section(body.header, body.body);\n    } else {\n      newBody = body.map(entry => [entry.name, entry.description]).map(_ref => {\n        let [left, right] = _ref;\n        return [this.render(left), right && this.render(right)];\n      });\n    }\n    const output = [bold(header), this.indent(Array.isArray(newBody) ? this.renderList(newBody, {\n      stripAnsi: this.opts.stripAnsi,\n      indentation: 2\n    }) : newBody)].join('\\n');\n    return this.opts.stripAnsi ? stripAnsi(output) : output;\n  }\n}\nexports.HelpFormatter = HelpFormatter;","map":{"version":3,"names":["Object","defineProperty","exports","value","HelpFormatter","Chalk","require","indent","stripAnsi","screen_1","util_1","width","widestLine","wrap","bold","constructor","config","opts","indentSpacing","maxWidth","stdtermwidth","render","template","body","spacing","hard","renderList","input","length","renderMultiline","output","left","right","trim","indentation","multiline","maxLength","map","i","join","spacer","cur","r","first","lines","split","s","repeat","section","header","newBody","Array","isArray","entry","tableEntry","name","description"],"sources":["/Users/wajahatfit/Documents/labs/portfolio/portfolio/node_modules/@oclif/core/lib/help/formatter.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HelpFormatter = void 0;\nconst Chalk = require(\"chalk\");\nconst indent = require(\"indent-string\");\nconst stripAnsi = require(\"strip-ansi\");\nconst screen_1 = require(\"../screen\");\nconst util_1 = require(\"./util\");\nconst width = require('string-width');\nconst widestLine = require('widest-line');\nconst wrap = require('wrap-ansi');\nconst { bold, } = Chalk;\nclass HelpFormatter {\n    constructor(config, opts = {}) {\n        this.indentSpacing = 2;\n        this.config = config;\n        this.opts = { maxWidth: screen_1.stdtermwidth, ...opts };\n        this.render = (0, util_1.template)(this);\n    }\n    /**\n     * Wrap text according to `opts.maxWidth` which is typically set to the terminal width. All text\n     * will be rendered before bring wrapped, otherwise it could mess up the lengths.\n     *\n     * A terminal will automatically wrap text, so this method is primarily used for indented\n     * text. For indented text, specify the indentation so it is taken into account during wrapping.\n     *\n     * Here is an example of wrapping with indentation.\n     * ```\n     * <------ terminal window width ------>\n     * <---------- no indentation --------->\n     * This is my text that will be wrapped\n     * once it passes maxWidth.\n     *\n     * <- indent -><------ text space ----->\n     *             This is my text that will\n     *             be wrapped once it passes\n     *             maxWidth.\n     *\n     * <-- indent not taken into account ->\n     *             This is my text that will\n     * be wrapped\n     *             once it passes maxWidth.\n     * ```\n     * @param body the text to wrap\n     * @param spacing the indentation size to subtract from the terminal width\n     * @returns the formatted wrapped text\n     */\n    wrap(body, spacing = this.indentSpacing) {\n        return wrap(this.render(body), this.opts.maxWidth - spacing, { hard: true });\n    }\n    /**\n     * Indent by `this.indentSpacing`. The text should be wrap based on terminal width before indented.\n     *\n     * In order to call indent multiple times on the same set or text, the caller must wrap based on\n     * the number of times the text has been indented. For example.\n     *\n     * ```javascript\n     * const body = `main line\\n${indent(wrap('indented example line', 4))}`\n     * const header = 'SECTION'\n     * console.log(`${header}\\n${indent(wrap(body))}`\n     * ```\n     * will output\n     * ```\n     * SECTION\n     *   main line\n     *     indented example line\n     * ```\n     *\n     * If the terminal width was 24 and the `4` was not provided in the first wrap, it would like like the following.\n     * ```\n     * SECTION\n     *   main line\n     *     indented example\n     *   line\n     * ```\n     * @param body the text to indent\n     * @param spacing the final number of spaces this text will be indented\n     * @return the formatted indented text\n     */\n    indent(body, spacing = this.indentSpacing) {\n        return indent(body, spacing);\n    }\n    renderList(input, opts) {\n        if (input.length === 0) {\n            return '';\n        }\n        const renderMultiline = () => {\n            let output = '';\n            for (let [left, right] of input) {\n                if (!left && !right)\n                    continue;\n                if (left) {\n                    if (opts.stripAnsi)\n                        left = stripAnsi(left);\n                    output += this.wrap(left.trim(), opts.indentation);\n                }\n                if (right) {\n                    if (opts.stripAnsi)\n                        right = stripAnsi(right);\n                    output += '\\n';\n                    output += this.indent(this.wrap(right.trim(), opts.indentation + 2), 4);\n                }\n                output += '\\n\\n';\n            }\n            return output.trim();\n        };\n        if (opts.multiline)\n            return renderMultiline();\n        const maxLength = widestLine(input.map(i => i[0]).join('\\n'));\n        let output = '';\n        let spacer = opts.spacer || '\\n';\n        let cur = '';\n        for (const [left, r] of input) {\n            let right = r;\n            if (cur) {\n                output += spacer;\n                output += cur;\n            }\n            cur = left || '';\n            if (opts.stripAnsi)\n                cur = stripAnsi(cur);\n            if (!right) {\n                cur = cur.trim();\n                continue;\n            }\n            if (opts.stripAnsi)\n                right = stripAnsi(right);\n            right = this.wrap(right.trim(), opts.indentation + maxLength + 2);\n            const [first, ...lines] = right.split('\\n').map(s => s.trim());\n            cur += ' '.repeat(maxLength - width(cur) + 2);\n            cur += first;\n            if (lines.length === 0) {\n                continue;\n            }\n            // if we start putting too many lines down, render in multiline format\n            if (lines.length > 4)\n                return renderMultiline();\n            // if spacer is not defined, separate all rows with a newline\n            if (!opts.spacer)\n                spacer = '\\n';\n            cur += '\\n';\n            cur += this.indent(lines.join('\\n'), maxLength + 2);\n        }\n        if (cur) {\n            output += spacer;\n            output += cur;\n        }\n        return output.trim();\n    }\n    section(header, body) {\n        // Always render template strings with the provided render function before wrapping and indenting\n        let newBody;\n        if (typeof body === 'string') {\n            newBody = this.render(body);\n        }\n        else if (Array.isArray(body)) {\n            newBody = body.map(entry => {\n                if ('name' in entry) {\n                    const tableEntry = entry;\n                    return ([this.render(tableEntry.name), this.render(tableEntry.description)]);\n                }\n                const [left, right] = entry;\n                return ([this.render(left), right && this.render(right)]);\n            });\n        }\n        else if ('header' in body) {\n            return this.section(body.header, body.body);\n        }\n        else {\n            newBody = body\n                .map((entry) => ([entry.name, entry.description]))\n                .map(([left, right]) => ([this.render(left), right && this.render(right)]));\n        }\n        const output = [\n            bold(header),\n            this.indent(Array.isArray(newBody) ? this.renderList(newBody, { stripAnsi: this.opts.stripAnsi, indentation: 2 }) : newBody),\n        ].join('\\n');\n        return this.opts.stripAnsi ? stripAnsi(output) : output;\n    }\n}\nexports.HelpFormatter = HelpFormatter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}